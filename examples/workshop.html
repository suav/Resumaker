<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resume Workshop - Unified UI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .header {
            background: white;
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .header h1 {
            color: #667eea;
            font-size: 1.5em;
            margin: 0;
        }
        
        .header p {
            color: #666;
            font-size: 0.9em;
            margin: 0;
        }
        
        .main-container {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: 15px;
            padding: 0 15px;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .sidebar {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            height: fit-content;
            position: sticky;
            top: 15px;
        }
        
        .sidebar h2 {
            font-size: 0.95em;
            margin-bottom: 8px;
            color: #555;
        }
        
        .sidebar .section {
            margin-bottom: 15px;
        }
        
        .sidebar button {
            padding: 8px 12px;
            font-size: 12px;
            width: 100%;
            margin: 3px 0;
        }
        
        .main-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            min-height: 80vh;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }
        
        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section h3 {
            color: #555;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            margin: 5px;
        }
        
        button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }
        
        button.secondary {
            background: #4a5568;
        }
        
        button.secondary:hover {
            background: #2d3748;
        }
        
        button.success {
            background: #48bb78;
        }
        
        button.success:hover {
            background: #38a169;
        }
        
        button.danger {
            background: #f56565;
        }
        
        button.danger:hover {
            background: #e53e3e;
        }
        
        textarea, input[type="text"], input[type="url"], select {
            width: 100%;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            margin: 5px 0;
            transition: all 0.3s ease;
        }
        
        textarea {
            min-height: 120px;
        }
        
        .job-description-area {
            transition: all 0.4s ease;
            resize: vertical;
        }
        
        .job-description-area.small {
            height: 60px;
            resize: none;
        }
        
        .job-description-area.large {
            height: 200px;
            min-height: 150px;
        }
        
        .job-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .job-input-row.small-mode {
            flex-direction: row;
        }
        
        .job-input-row.large-mode {
            flex-direction: column;
            gap: 15px;
        }
        
        .linkedin-section {
            display: flex;
            gap: 8px;
            align-items: center;
            min-width: 300px;
        }
        
        .linkedin-section.large-mode {
            min-width: auto;
            width: 100%;
        }
        
        .linkedin-section.hidden {
            display: none !important;
        }
        
        .linkedin-section.minimal {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            opacity: 0.7;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .linkedin-section.minimal input {
            font-size: 12px;
            padding: 6px;
        }
        
        .linkedin-section.minimal button {
            font-size: 11px;
            padding: 6px 8px;
        }
        
        .linkedin-section input {
            margin: 0;
        }
        
        .job-actions {
            margin-top: 10px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .job-actions.visible {
            opacity: 1;
            max-height: 50px;
        }
        
        /* Scroll-minimized states */
        .workflow-step.minimized {
            background: rgba(102, 126, 234, 0.05);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            transition: all 0.4s ease;
        }
        
        .workflow-step.minimized .job-selector-section {
            display: block;
        }
        
        .workflow-step.minimized .job-input-row,
        .workflow-step.minimized .job-actions {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            margin: 0;
            padding: 0;
            transition: all 0.3s ease;
        }
        
        .workflow-step.minimized h3 {
            font-size: 0.95em;
            margin-bottom: 8px;
        }
        
        .workflow-step.minimized h3::after {
            content: " - " attr(data-current-job);
            font-weight: normal;
            font-style: italic;
            color: #667eea;
            font-size: 0.9em;
        }
        
        /* Dynamic Job Description Sizing */
        .job-description-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: all 0.3s ease;
        }
        
        .job-description-container.compact {
            flex-direction: row;
            align-items: flex-start;
            gap: 15px;
        }
        
        .job-description-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .job-description-area {
            transition: all 0.3s ease;
            min-height: 60px;
            height: 60px;
            resize: none;
        }
        
        .job-description-area.small {
            min-height: 60px;
            height: 60px;
        }
        
        .job-description-area.large {
            min-height: 200px;
            height: 200px;
            resize: vertical;
        }
        
        .linkedin-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
            transition: all 0.3s ease;
        }
        
        .job-description-container.compact .linkedin-section {
            flex-direction: row;
            align-items: center;
            min-width: auto;
            flex-shrink: 0;
        }
        
        .job-description-container.compact .linkedin-section input {
            margin: 0;
            width: 250px;
        }
        
        .job-description-container.compact .linkedin-section button {
            margin: 0;
            white-space: nowrap;
        }
        
        .save-job-section {
            margin-top: 10px;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            visibility: hidden;
        }
        
        .save-job-section.visible {
            opacity: 1;
            transform: translateY(0);
            visibility: visible;
        }
        
        .parent-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .parent-option {
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .parent-option:hover {
            border-color: #667eea;
        }
        
        .parent-option.selected {
            border-color: #48bb78;
            background: #f0fff4;
        }
        
        .parent-option.hybrid-parent {
            border-color: #805ad5;
            background: #faf5ff;
        }
        
        .variant-preview {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .variant-header {
            background: #f7fafc;
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .variant-title {
            font-weight: bold;
            color: #2d3748;
        }
        
        .variant-badge {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }
        
        .variant-badge.hybrid {
            background: #805ad5;
        }
        
        .variant-content {
            padding: 15px;
        }
        
        .variant-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-indicator.success {
            background: #48bb78;
        }
        
        .status-indicator.warning {
            background: #ed8936;
        }
        
        .status-indicator.error {
            background: #f56565;
        }
        
        .creation-mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
        }
        
        .mode-button {
            flex: 1;
            padding: 15px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }
        
        .mode-button.active {
            border-color: #667eea;
            background: #e6fffa;
        }
        
        .mode-button:hover {
            border-color: #667eea;
        }
        
        .genealogy-tree {
            margin: 20px 0;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
        }
        
        .tree-node {
            margin: 10px 0;
            padding: 10px;
            border-left: 3px solid #667eea;
            background: white;
            border-radius: 4px;
        }
        
        .tree-node.hybrid {
            border-left-color: #805ad5;
        }
        
        .tree-children {
            margin-left: 20px;
            border-left: 1px dashed #ccc;
            padding-left: 20px;
        }
        
        .workflow-step {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            position: relative;
        }
        
        .workflow-step.active {
            background: #e6fffa;
            border-color: #4fd1c7;
        }
        
        .workflow-step.completed {
            background: #f0fff4;
            border-color: #48bb78;
        }
        
        .step-number {
            position: absolute;
            top: -10px;
            left: 15px;
            background: #48bb78;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            border-left: 4px solid #48bb78;
        }
        
        .notification.error {
            border-left: 4px solid #f56565;
        }
        
        .notification.warning {
            border-left: 4px solid #ed8936;
        }
        
        .tab-container {
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 20px;
        }
        
        .tab-buttons {
            display: flex;
            gap: 0;
        }
        
        .tab-button {
            background: none;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            color: #666;
        }
        
        .tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #f7fafc;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .quick-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        
        .job-selector-section {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .job-selector-section h4 {
            margin-bottom: 10px;
            color: #555;
        }
        
        /* Tree Visualization Styles */
        .tree-visualization {
            position: relative;
            padding: 20px;
            background: white;
            border-radius: 12px;
            overflow-x: auto;
            min-height: 600px;
        }
        
        .tree-svg {
            width: 100%;
            height: 100%;
            min-height: 600px;
        }
        
        .tree-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tree-node:hover .node-rect {
            filter: brightness(1.1);
            stroke-width: 3;
        }
        
        .node-rect {
            rx: 8;
            ry: 8;
            transition: all 0.3s ease;
        }
        
        .node-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
        
        .node-title {
            font-weight: bold;
            font-size: 13px;
        }
        
        .node-subtitle {
            font-size: 11px;
            opacity: 0.8;
        }
        
        .tree-link {
            fill: none;
            stroke: #999;
            stroke-width: 2;
            opacity: 0.6;
        }
        
        .tree-link-hybrid {
            stroke: #48bb78;
            stroke-dasharray: 5,5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -100;
            }
        }
        
        .tree-legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 3px;
        }
        
        /* Dashboard Grid Improvements */
        .variant-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }
        
        /* Enhanced Compact Dashboard */
        .variant-grid-enhanced {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .variant-card-compact {
            background: white;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            padding: 12px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .variant-card-compact:hover {
            border-color: #cbd5e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .variant-card-compact.is-recent {
            border: 2px solid #48bb78;
            box-shadow: 0 0 12px rgba(72, 187, 120, 0.15);
            animation: pulse-new 2s ease-in-out infinite;
        }
        
        @keyframes pulse-new {
            0%, 100% { box-shadow: 0 0 12px rgba(72, 187, 120, 0.15); }
            50% { box-shadow: 0 0 20px rgba(72, 187, 120, 0.3); }
        }
        
        .priority-global {
            border-left: 4px solid #f6ad55;
            background: linear-gradient(135deg, #fffbf0 0%, #ffffff 100%);
        }
        
        .priority-job {
            border-left: 4px solid #4fd1c7;
            background: linear-gradient(135deg, #f0ffff 0%, #ffffff 100%);
        }
        
        .priority-advanced {
            border-left: 4px solid #9f7aea;
            background: linear-gradient(135deg, #faf5ff 0%, #ffffff 100%);
        }
        
        .priority-normal {
            border-left: 3px solid #e2e8f0;
        }
        
        .variant-card-header {
            margin-bottom: 8px;
        }
        
        .variant-title-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 4px;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .variant-title-compact {
            font-weight: 600;
            font-size: 0.9rem;
            color: #2d3748;
            line-height: 1.2;
            flex: 1;
            min-width: 0;
        }
        
        .badges-row {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        
        .badge-new {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            animation: glow-new 2s ease-in-out infinite;
        }
        
        @keyframes glow-new {
            0%, 100% { box-shadow: 0 0 4px rgba(72, 187, 120, 0.4); }
            50% { box-shadow: 0 0 8px rgba(72, 187, 120, 0.6); }
        }
        
        .parent-info {
            background: #f7fafc;
            color: #4a5568;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            border: 1px solid #e2e8f0;
        }
        
        .btn-compact.compare {
            background: #bee3f8;
            color: #2b6cb0;
            border-color: #90cdf4;
        }
        
        .btn-compact.compare:hover {
            background: #90cdf4;
        }
        
        /* Comparison Modal */
        .comparison-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .comparison-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            height: 80%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .comparison-header h3 {
            margin: 0;
            color: #2d3748;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #718096;
            padding: 5px;
        }
        
        .close-btn:hover {
            color: #2d3748;
        }
        
        .comparison-body {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 20px;
            overflow: hidden;
        }
        
        .comparison-side {
            display: flex;
            flex-direction: column;
        }
        
        .comparison-side h4 {
            margin: 0 0 10px 0;
            color: #4a5568;
            font-size: 14px;
        }
        
        .comparison-actions {
            padding: 15px 20px;
            border-top: 1px solid #e2e8f0;
            text-align: center;
        }
        
        /* Enhanced Tree View Styles */
        .tree-container {
            display: flex;
            height: 600px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            background: #f8f9fa;
        }
        
        .tree-minimap {
            width: 350px;
            background: white;
            border-right: 1px solid #e2e8f0;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .minimap-header {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8f9fa;
        }
        
        .minimap-header h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #2d3748;
        }
        
        .minimap-controls {
            display: flex;
            gap: 8px;
        }
        
        .minimap-btn {
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .minimap-btn:hover {
            background: #3367d6;
        }
        
        .minimap-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .minimap-viewport {
            position: absolute;
            border: 3px solid #4285f4;
            background: rgba(66, 133, 244, 0.15);
            pointer-events: none;
            z-index: 10;
            border-radius: 2px;
        }
        
        .minimap-svg {
            display: block;
            width: 100%;
            height: 100%;
            min-height: 200px;
        }
        
        .tree-main-view {
            flex: 1;
            overflow: hidden;
            cursor: grab;
            position: relative;
            max-width: 800px; /* Constrain main view width for focus */
            max-height: 600px; /* Constrain main view height */
        }
        
        .tree-canvas {
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }
        
        /* Tree Card Styles */
        .tree-card {
            position: absolute;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 12px;
            transition: all 0.2s ease;
            z-index: 5;
        }
        
        .tree-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            border-color: #cbd5e0;
        }
        
        .tree-card.recent {
            border: 2px solid #48bb78;
            box-shadow: 0 0 12px rgba(72, 187, 120, 0.15);
            animation: pulse-new 2s ease-in-out infinite;
        }
        
        .tree-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .tree-card-title {
            font-weight: 600;
            font-size: 14px;
            color: #2d3748;
            line-height: 1.2;
            flex: 1;
            margin-right: 8px;
        }
        
        .tree-card-badges {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        
        .tree-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
            white-space: nowrap;
        }
        
        .tree-badge.new {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            animation: glow-new 2s ease-in-out infinite;
        }
        
        .tree-badge.hybrid {
            background: linear-gradient(135deg, #f56565, #ed8936);
            color: white;
        }
        
        .tree-badge.generation {
            background: #edf2f7;
            color: #4a5568;
        }
        
        .tree-card-content {
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .tree-card-desc {
            color: #4a5568;
            margin-bottom: 4px;
            line-height: 1.3;
        }
        
        .tree-card-job {
            color: #2b6cb0;
            font-size: 11px;
            margin-bottom: 2px;
        }
        
        .tree-card-parent {
            color: #718096;
            font-size: 11px;
        }
        
        .tree-card-actions {
            display: flex;
            gap: 4px;
            justify-content: flex-end;
        }
        
        .tree-btn {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .tree-btn:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }
        
        .tree-btn.delete {
            background: #fed7d7;
            border-color: #feb2b2;
            color: #c53030;
        }
        
        .tree-btn.delete:hover {
            background: #fbb6ce;
        }
        
        .tree-btn.branch {
            background: #c6f6d5;
            border-color: #9ae6b4;
            color: #22543d;
        }
        
        .tree-btn.branch:hover {
            background: #9ae6b4;
        }

        /* Quick Branch Modal */
        .quick-branch-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quick-branch-content {
            background: white;
            border-radius: 8px;
            width: 500px;
            max-width: 90%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .quick-branch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .quick-branch-header h3 {
            margin: 0;
            color: #2d3748;
        }

        .quick-branch-header button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #718096;
        }

        .quick-branch-form {
            padding: 20px;
        }

        .quick-branch-form .form-group {
            margin-bottom: 15px;
        }

        .quick-branch-form label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #4a5568;
        }

        .quick-branch-form input,
        .quick-branch-form select,
        .quick-branch-form textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
        }

        .quick-branch-form textarea {
            height: 80px;
            resize: vertical;
        }

        .quick-branch-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .form-divider {
            text-align: center;
            margin: 20px 0;
            position: relative;
        }

        .form-divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e2e8f0;
        }

        .form-divider span {
            background: white;
            padding: 0 15px;
            color: #718096;
            font-size: 0.9rem;
            font-weight: 500;
        }

        /* Creating state for tree cards */
        .tree-card.creating {
            opacity: 0.8;
            border: 2px dashed #48bb78;
            animation: pulse-creating 2s ease-in-out infinite;
        }

        /* Placeholder nodes being built */
        .tree-card.placeholder {
            opacity: 0.7;
            filter: grayscale(50%);
            border: 2px dashed #94a3b8;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            animation: pulse-building 3s ease-in-out infinite;
        }

        .tree-card.placeholder .tree-card-title {
            color: #64748b;
        }

        .tree-card.placeholder .tree-btn {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes pulse-creating {
            0%, 100% { 
                border-color: #48bb78;
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0.4);
            }
            50% { 
                border-color: #38a169;
                box-shadow: 0 0 0 4px rgba(72, 187, 120, 0.2);
            }
        }

        @keyframes pulse-building {
            0%, 100% { 
                border-color: #94a3b8;
                box-shadow: 0 0 0 0 rgba(148, 163, 184, 0.3);
            }
            50% { 
                border-color: #64748b;
                box-shadow: 0 0 0 4px rgba(148, 163, 184, 0.2);
            }
        }

        /* Progress bar for building variants */
        .tree-card-progress {
            margin-top: 8px;
            font-size: 0.75rem;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #06b6d4);
            width: 0%;
            animation: progress-indeterminate 2s ease-in-out infinite;
        }

        @keyframes progress-indeterminate {
            0% { 
                width: 0%;
                margin-left: 0%;
            }
            50% { 
                width: 40%;
                margin-left: 30%;
            }
            100% { 
                width: 0%;
                margin-left: 100%;
            }
        }

        .progress-text {
            color: #64748b;
            font-size: 0.7rem;
            font-style: italic;
        }

        /* Placeholder connection lines */
        .placeholder-connection {
            opacity: 0.6;
            stroke-dasharray: 5,5;
            animation: dash-move 2s linear infinite;
        }

        @keyframes dash-move {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: 20; }
        }

        /* Status badges */
        .tree-badge.status {
            font-size: 0.65rem;
            margin-right: 4px;
        }

        .tree-badge.status.creating {
            background: #fef7e0;
            color: #b7791f;
            border: 1px solid #ecc94b;
            animation: status-pulse 2s ease-in-out infinite;
        }

        .tree-badge.status.processing {
            background: #e0f2fe;
            color: #0277bd;
            border: 1px solid #4fc3f7;
            animation: status-pulse 1.5s ease-in-out infinite;
        }

        .tree-badge.status.completed {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #66bb6a;
        }

        .tree-badge.status.failed {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ef5350;
        }

        .tree-badge.status.pending {
            background: #f5f5f5;
            color: #616161;
            border: 1px solid #bdbdbd;
        }

        @keyframes status-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Connection Lines */
        .tree-connections {
            pointer-events: none;
        }
        
        .tree-connection {
            stroke: #a0aec0;
            stroke-width: 2;
        }
        
        .tree-connection.hybrid {
            stroke: #f56565;
            stroke-dasharray: 5,5;
        }
        
        .variant-meta-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            flex-wrap: wrap;
        }
        
        .generation-indicator {
            background: #edf2f7;
            color: #4a5568;
            padding: 2px 6px;
            border-radius: 12px;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .gen-0 { background: #f7fafc; color: #2d3748; }
        .gen-1 { background: #f0fff4; color: #276749; }
        .gen-2 { background: #fffaf0; color: #744210; }
        .gen-3 { background: #fff5f5; color: #742a2a; }
        .gen-4 { background: #faf5ff; color: #553c9a; }
        
        .variant-type-compact {
            background: #e2e8f0;
            color: #4a5568;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            white-space: nowrap;
        }
        
        .variant-type-compact.hybrid {
            background: #feebc8;
            color: #7b341e;
        }
        
        .variant-time-compact {
            color: #718096;
            margin-left: auto;
            white-space: nowrap;
        }
        
        .variant-card-content {
            margin-bottom: 10px;
        }
        
        .variant-description-compact {
            font-size: 0.8rem;
            color: #4a5568;
            line-height: 1.3;
            margin: 0 0 6px 0;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .variant-job-info {
            font-size: 0.75rem;
            color: #718096;
            margin-top: 4px;
        }
        
        .variant-card-actions {
            display: flex;
            gap: 4px;
            justify-content: flex-end;
        }
        
        .btn-compact {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .btn-compact:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }
        
        .btn-compact.preview:hover {
            background: #ebf8ff;
            border-color: #90cdf4;
        }
        
        .btn-compact.export:hover {
            background: #f0fff4;
            border-color: #9ae6b4;
        }
        
        .btn-compact.star:hover {
            background: #fffbf0;
            border-color: #f6ad55;
        }
        
        .btn-compact.quality:hover {
            background: #f0f9ff;
            border-color: #60a5fa;
        }
        
        .btn-compact.delete:hover {
            background: #fef2f2;
            border-color: #f87171;
            color: #dc2626;
        }
        
        .preference-badge {
            font-size: 0.65rem;
            padding: 2px 5px;
            border-radius: 8px;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .preference-badge.global {
            background: #fffbf0;
            color: #744210;
            border: 1px solid #f6ad55;
        }
        
        .preference-badge.job {
            background: #f0ffff;
            color: #234e52;
            border: 1px solid #4fd1c7;
        }
        
        .preference-badge.base {
            background: #faf5ff;
            color: #553c9a;
            border: 1px solid #9f7aea;
        }
        
        .preference-menu {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            padding: 8px;
            min-width: 200px;
        }
        
        .preference-menu button {
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-bottom: 2px;
        }
        
        .preference-menu button:hover {
            background: #f7fafc;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #718096;
            font-style: italic;
            grid-column: 1 / -1;
        }
        
        /* Batch Testing Styles */
        .batch-config {
            background: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .batch-config h4 {
            margin: 0 0 12px 0;
            color: #2d3748;
            font-size: 1rem;
        }
        
        .batch-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .batch-option {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 10px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .batch-option:hover {
            border-color: #cbd5e0;
            background: #f7fafc;
        }
        
        .batch-option input[type="checkbox"] {
            margin: 0;
            flex-shrink: 0;
        }
        
        .batch-option span {
            font-size: 0.9rem;
            line-height: 1.3;
        }
        
        #custom-directives {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
        
        .batch-controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .batch-settings {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .batch-settings label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }
        
        .batch-actions {
            display: flex;
            gap: 10px;
        }
        
        .progress-container {
            background: #f7fafc;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            font-size: 0.9rem;
            color: #4a5568;
            text-align: center;
        }
        
        .agent-status-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .agent-status-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .agent-status-icon {
            font-size: 1.2rem;
        }
        
        .agent-status-text {
            flex: 1;
            font-size: 0.85rem;
        }
        
        .agent-status-name {
            font-weight: 600;
            color: #2d3748;
        }
        
        .agent-status-progress {
            color: #718096;
            font-size: 0.8rem;
        }
        
        .batch-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .batch-result-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.2s ease;
        }
        
        .batch-result-card:hover {
            border-color: #cbd5e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .batch-result-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        
        .batch-result-title {
            font-weight: 600;
            color: #2d3748;
            flex: 1;
        }
        
        .batch-result-strategy {
            background: #edf2f7;
            color: #4a5568;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7rem;
            white-space: nowrap;
        }
        
        .batch-result-preview {
            font-size: 0.85rem;
            color: #718096;
            margin-bottom: 12px;
            line-height: 1.4;
        }
        
        .batch-result-actions {
            display: flex;
            gap: 6px;
            justify-content: space-between;
        }
        
        .batch-result-actions button {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.8rem;
        }
        
        /* Quality Control Modal Styles */
        .quality-modal, .prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
        }
        
        .quality-modal.active, .prompt-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .quality-container, .prompt-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            position: relative;
        }
        
        .quality-header, .prompt-header {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .quality-header h3, .prompt-header h3 {
            margin: 0;
            color: #2d3748;
        }
        
        .quality-close, .prompt-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
        }
        
        .quality-content, .prompt-content {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(90vh - 80px);
        }
        
        .quality-section, .prompt-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f1f3f4;
        }
        
        .quality-section:last-of-type, .prompt-section:last-of-type {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .quality-section h4, .prompt-section h4 {
            margin: 0 0 15px 0;
            color: #2d3748;
            font-size: 1rem;
        }
        
        .star-rating {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .star {
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        
        .star.active, .star:hover {
            opacity: 1;
        }
        
        .rating-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #666;
        }
        
        .feedback-checkboxes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .feedback-checkboxes label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        #quality-feedback, .prompt-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .prompt-textarea {
            min-height: 120px;
        }
        
        .benchmark-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .benchmark-section select {
            flex: 1;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }
        
        .quality-analysis, .example-analysis {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .issue-patterns {
            background: #fef5e7;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #f6ad55;
        }
        
        .issue-item {
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        .issue-item:last-child {
            margin-bottom: 0;
        }
        
        .quality-actions, .prompt-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn-primary {
            background: #4299e1;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .btn-primary:hover {
            background: #3182ce;
        }
        
        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .btn-secondary:hover {
            background: #cbd5e0;
        }
        
        .btn-success {
            background: #38a169;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .btn-success:hover {
            background: #2f855a;
        }
        
        .btn-danger {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .btn-danger:hover {
            background: #c53030;
        }
        
        /* Enhanced Parent Selector Styles */
        .parent-selector-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .selector-view-options {
            display: flex;
            gap: 5px;
        }
        
        .view-toggle {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        
        .view-toggle.active {
            background: #4299e1;
            color: white;
            border-color: #4299e1;
        }
        
        .view-toggle:hover:not(.active) {
            background: #edf2f7;
            border-color: #cbd5e0;
        }
        
        .selector-filters {
            display: flex;
            gap: 10px;
        }
        
        .selector-filters select {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
        }
        
        .parent-selector-view {
            display: none;
            min-height: 200px;
        }
        
        .parent-selector-view.active {
            display: block;
        }
        
        .parent-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 15px;
        }
        
        .parent-option-card {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .parent-option-card:hover {
            border-color: #cbd5e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .parent-option-card.selected {
            border-color: #4299e1;
            background: #f0f9ff;
            box-shadow: 0 0 0 1px #4299e1;
        }
        
        .parent-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        
        .parent-card-title {
            font-weight: 600;
            color: #2d3748;
            font-size: 1rem;
            line-height: 1.2;
            flex: 1;
        }
        
        .parent-card-badges {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .parent-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .parent-badge.generation {
            background: #e2e8f0;
            color: #4a5568;
        }
        
        .parent-badge.recent {
            background: #fed7d7;
            color: #742a2a;
        }
        
        .parent-badge.quality {
            background: #feebc8;
            color: #7b341e;
        }
        
        .parent-card-job {
            font-size: 0.85rem;
            color: #718096;
            margin-bottom: 8px;
            font-style: italic;
        }
        
        .parent-card-lineage {
            font-size: 0.8rem;
            color: #4a5568;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: #f7fafc;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
        }
        
        .parent-card-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: #718096;
            margin-bottom: 10px;
        }
        
        .parent-card-actions {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
        }
        
        .parent-mini-btn {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .parent-mini-btn:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }
        
        .parent-mini-btn.preview:hover {
            background: #ebf8ff;
            border-color: #90cdf4;
        }
        
        /* Horizontal Tree View */
        .horizontal-tree {
            background: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            overflow-x: auto;
            min-height: 300px;
        }
        
        .tree-generation {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            min-height: 80px;
        }
        
        .tree-gen-label {
            background: #4299e1;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
            margin-right: 20px;
            min-width: 80px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .tree-gen-items {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            flex: 1;
        }
        
        .tree-node {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            min-width: 200px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .tree-node:hover {
            border-color: #cbd5e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .tree-node.selected {
            border-color: #4299e1;
            background: #f0f9ff;
        }
        
        .tree-node-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: #2d3748;
            margin-bottom: 4px;
        }
        
        .tree-node-job {
            font-size: 0.75rem;
            color: #718096;
            margin-bottom: 4px;
        }
        
        .tree-node-parent {
            font-size: 0.7rem;
            color: #a0aec0;
            font-style: italic;
        }
        
        /* Hierarchical Tree Styles */
        .tree-node-hierarchical {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
            margin: 8px 0;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .tree-node-hierarchical:hover {
            border-color: #cbd5e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .tree-node-hierarchical.selected {
            border-color: #4299e1;
            background: #f0f9ff;
        }
        
        .tree-node-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tree-node-icon {
            font-size: 1rem;
            flex-shrink: 0;
        }
        
        .tree-node-details {
            flex: 1;
        }
        
        .tree-node-meta {
            display: flex;
            gap: 8px;
            font-size: 0.75rem;
            color: #718096;
            margin-top: 2px;
        }
        
        .tree-node-generation {
            background: #e2e8f0;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .tree-node-type {
            background: #f0fff4;
            color: #38a169;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .tree-orphaned-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px dashed #e2e8f0;
        }
        
        .tree-section-title {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        /* Improved Card Styles */
        .parent-card {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .parent-card:hover {
            border-color: #cbd5e0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .parent-card.selected {
            border-color: #4299e1;
            background: #f0f9ff;
            box-shadow: 0 0 0 1px #4299e1;
        }
        
        .card-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }
        
        .card-title {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.95rem;
            line-height: 1.3;
            flex: 1;
            margin-right: 8px;
        }
        
        .card-badges {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        
        .gen-badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
        }
        
        .gen-badge.gen-0 { background: #68d391; }
        .gen-badge.gen-1 { background: #4299e1; }
        .gen-badge.gen-2 { background: #9f7aea; }
        .gen-badge.gen-3 { background: #f56565; }
        .gen-badge.gen-4 { background: #ed8936; }
        
        .recent-badge {
            background: #38a169;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .hybrid-badge {
            background: #805ad5;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .card-meta {
            margin-bottom: 12px;
        }
        
        .job-type {
            color: #4a5568;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 4px;
        }
        
        .lineage {
            color: #718096;
            font-size: 0.8rem;
            font-style: italic;
        }
        
        .card-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .preview-btn {
            background: #4299e1;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .preview-btn:hover {
            background: #3182ce;
            transform: scale(1.05);
        }
        
        .creation-date {
            font-size: 0.75rem;
            color: #a0aec0;
        }
        
        .no-results {
            grid-column: 1 / -1;
            text-align: center;
            padding: 60px 20px;
            color: #718096;
            font-size: 1rem;
        }
        
        /* Tree View Previews */
        .tree-node-preview {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: all 0.2s ease;
        }
        
        .tree-node:hover .tree-node-preview {
            opacity: 1;
        }
        
        .tree-preview-btn {
            background: #4299e1;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tree-preview-btn:hover {
            background: #3182ce;
        }
        
        /* Selection Summary */
        .selection-summary {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-top: 20px;
        }
        
        .selection-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .selection-count {
            font-weight: 600;
            color: #2d3748;
        }
        
        .mode-indicator {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        
        .mode-indicator.single {
            background: #e6fffa;
            color: #234e52;
        }
        
        .mode-indicator.hybrid {
            background: #feebc8;
            color: #7b341e;
        }
        
        .selected-templates {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .selected-template-tag {
            background: #4299e1;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .selected-template-tag .remove {
            cursor: pointer;
            font-weight: bold;
        }
        
        .selected-template-tag .remove:hover {
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .variant-preview {
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .variant-preview:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .variant-preview.preferred-global {
            border: 2px solid #48bb78;
            box-shadow: 0 0 0 3px rgba(72, 187, 120, 0.1);
        }
        
        .variant-preview.preferred-job {
            border: 2px solid #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .variant-preview.base-template {
            border: 2px solid #f6ad55;
            box-shadow: 0 0 0 3px rgba(246, 173, 85, 0.1);
        }
        
        .variant-header {
            background: #f7fafc;
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .variant-title {
            font-weight: bold;
            font-size: 0.9em;
            color: #2d3748;
        }
        
        .variant-badge {
            background: #667eea;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 500;
        }
        
        .variant-badge.hybrid {
            background: #f56565;
        }
        
        .variant-badge.base {
            background: #f6ad55;
        }
        
        .variant-content {
            padding: 12px 15px;
        }
        
        .variant-content p {
            margin: 0 0 8px 0;
            font-size: 0.85em;
            color: #4a5568;
            line-height: 1.4;
        }
        
        .variant-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .variant-actions button {
            padding: 6px 12px;
            font-size: 0.8em;
            margin: 0;
        }
        
        .generation-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            font-weight: bold;
        }
        
        .preference-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            font-weight: bold;
            color: white;
        }
        
        .preference-badge.global {
            background: #48bb78;
        }
        
        .preference-badge.job {
            background: #667eea;
        }
        
        .preference-badge.base {
            background: #f6ad55;
        }
        
        /* Preview Overlay */
        .preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .preview-overlay.active {
            display: flex;
        }
        
        .preview-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 8.5in;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            position: relative;
        }
        
        .preview-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .preview-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .preview-download {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }
        
        .preview-download:hover {
            background: #218838;
        }
        
        .preview-download:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .preview-title {
            font-weight: bold;
            color: #495057;
        }
        
        .preview-close {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .preview-content {
            height: 11in;
            max-height: calc(90vh - 70px);
            overflow-y: auto;
            background: white;
        }
        
        .preview-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
        }
        
        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .header {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <h1>🎯 Resume Workshop</h1>
            <p>| Unified Platform</p>
        </div>
        <div class="header-right">
            <span id="quick-status" style="font-size: 0.9em; color: #666;">Variants: <strong id="header-variant-count">-</strong> | Jobs: <strong id="header-job-count">-</strong></span>
        </div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="section">
                <h2>Quick Nav</h2>
                <button onclick="showTab('dashboard')">📋 Dashboard</button>
                <button onclick="showTab('create-resume')">➕ Create</button>
                <button onclick="showTab('manage-jobs')">💼 Jobs</button>
                <button onclick="showTab('genealogy')">🌳 Tree</button>
            </div>
            
            <div class="section" style="font-size: 0.85em; color: #666;">
                <h2>Stats</h2>
                <div>Variants: <strong id="variant-count">-</strong></div>
                <div>Jobs: <strong id="job-count">-</strong></div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="showTab('dashboard')">Dashboard</button>
                    <button class="tab-button" onclick="showTab('create-resume')">Create Resume</button>
                    <button class="tab-button" onclick="showTab('manage-jobs')">Job Manager</button>
                    <button class="tab-button" onclick="showTab('genealogy')">Evolution Tree</button>
                </div>
            </div>
            
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <h2>📋 Resume Variants Dashboard</h2>
                
                <!-- Search Section -->
                <div class="section" style="margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" id="search-input" placeholder="Search by job title, company, or description..." style="flex: 1;">
                        <button onclick="clearSearch()">Clear</button>
                    </div>
                    <div id="search-status" style="margin-top: 5px; font-size: 0.9em; color: #666;"></div>
                </div>
                
                <div id="variants-dashboard">
                    <div>Loading variants...</div>
                </div>
            </div>
            
            <!-- Unified Create Resume Tab -->
            <div id="create-resume" class="tab-content">
                <h2>🎨 Create Resume Variant</h2>
                
                <!-- Job Description Selection -->
                <div class="workflow-step">
                    <div class="step-number">1</div>
                    <h3>📋 Job Description & Context</h3>
                    <div class="job-selector-section">
                        <h4>Select Existing Job or Create New</h4>
                        <select id="job-selector" onchange="loadJobDescription()">
                            <option value="">Create new job description...</option>
                        </select>
                    </div>
                    <div class="job-input-row small-mode" id="job-input-container">
                        <textarea id="job-description" class="job-description-area small" placeholder="Paste job description or select existing job above..."></textarea>
                        <div class="linkedin-section" id="linkedin-section">
                            <input type="text" id="linkedin-url" placeholder="LinkedIn URL" style="flex: 1;">
                            <button onclick="fetchLinkedInJob()" style="white-space: nowrap;">📥 Fetch</button>
                        </div>
                    </div>
                    <div class="job-actions" id="job-actions">
                        <button onclick="saveCurrentJobDescription()" class="secondary">💾 Save Job Description</button>
                    </div>
                </div>
                
                <!-- Enhanced Parent Selection -->
                <div class="workflow-step" id="parent-selection-step">
                    <div class="step-number">2</div>
                    <h3>📄 Select Parent Template(s)</h3>
                    <div class="parent-selector-controls">
                        <div class="selector-view-options">
                            <button class="view-toggle active" data-view="detailed" onclick="switchSelectorView('detailed')">📋 Detailed View</button>
                            <button class="view-toggle" data-view="tree" onclick="switchSelectorView('tree')">🌳 Tree View</button>
                        </div>
                        <div class="selector-filters">
                            <select id="job-filter" onchange="filterParentOptions()">
                                <option value="">All Jobs</option>
                            </select>
                            <select id="generation-filter" onchange="filterParentOptions()">
                                <option value="">All Generations</option>
                                <option value="0">Gen 0 (Base)</option>
                                <option value="1">Gen 1</option>
                                <option value="2">Gen 2</option>
                                <option value="3">Gen 3+</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Detailed View -->
                    <div id="detailed-selector" class="parent-selector-view active">
                        <div class="parent-cards-grid" id="parent-cards-grid">
                            <!-- Parent option cards will be loaded here -->
                        </div>
                    </div>
                    
                    <!-- Tree View -->
                    <div id="tree-selector" class="parent-selector-view">
                        <div class="horizontal-tree" id="horizontal-tree">
                            <!-- Horizontal tree will be loaded here -->
                        </div>
                    </div>
                    
                    <div class="selection-summary">
                        <div class="selection-info">
                            <span class="selection-count">
                                <span id="selected-count">0</span> templates selected
                            </span>
                            <span id="mode-indicator" class="mode-indicator"></span>
                        </div>
                        <div class="selected-templates" id="selected-templates-display">
                            <!-- Selected templates will appear here -->
                        </div>
                    </div>
                </div>
                
                <!-- Configuration -->
                <div class="workflow-step">
                    <div class="step-number">3</div>
                    <h3>⚙️ Variant Configuration</h3>
                    <input type="text" id="variant-name" placeholder="Variant name (optional - will auto-generate)">
                    <select id="focus-type">
                        <option value="">General Optimization</option>
                        <option value="tech">Technical Focus</option>
                        <option value="leadership">Leadership Focus</option>
                        <option value="startup">Startup Optimized</option>
                        <option value="enterprise">Enterprise Optimized</option>
                        <option value="remote">Remote Position</option>
                        <option value="local">Local Position</option>
                    </select>
                    
                    <!-- Agent Command Selection for Single Generation -->
                    <div id="agent-command-section" style="margin-top: 15px;">
                        <label for="agent-command" style="display: block; margin-bottom: 5px; font-weight: 600;">AI Agent Command:</label>
                        <select id="agent-command">
                            <option value="optimize">Standard Optimization</option>
                            <option value="enhance_keywords">Enhance Keywords</option>
                            <option value="improve_ats">Improve ATS Compatibility</option>
                            <option value="customize_role">Customize for Role</option>
                            <option value="strengthen_metrics">Strengthen Metrics</option>
                            <option value="format_cleanup">Format Cleanup</option>
                            <option value="professional_tone">Professional Tone</option>
                            <option value="technical_focus">Technical Focus</option>
                            <option value="leadership_emphasis">Leadership Emphasis</option>
                            <option value="custom">Custom Command</option>
                        </select>
                    </div>
                    
                    <!-- Custom Notes/Instructions -->
                    <div style="margin-top: 15px;">
                        <label for="generation-notes" style="display: block; margin-bottom: 5px; font-weight: 600;">Notes & Instructions:</label>
                        <textarea id="generation-notes" placeholder="Add specific notes, requirements, or instructions for the AI agent...
Examples:
- Focus on Python and React skills
- Emphasize remote work experience
- Highlight leadership achievements
- Optimize for ATS systems" style="min-height: 80px; width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px; font-size: 0.9rem;"></textarea>
                    </div>
                    
                    <textarea id="variant-description" placeholder="Describe specific features to combine (for hybrids) or focus areas..." style="display: none;"></textarea>
                    <div style="margin-top: 15px;">
                        <button class="success" onclick="createResume()" id="create-button">🚀 Generate Resume</button>
                        <button class="secondary" onclick="showBatchTesting()" id="batch-button" style="margin-left: 10px;">🔬 Batch Test Variants</button>
                    </div>
                </div>
                
                <!-- Batch Testing Section -->
                <div class="workflow-step" id="batch-testing-step" style="display: none;">
                    <div class="step-number">4</div>
                    <h3>🔬 Batch Variant Testing</h3>
                    <div style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                        Launch multiple sub-agents to create variants with different optimization strategies for A/B testing.
                    </div>
                    
                    <div class="batch-config">
                        <h4>Testing Strategy</h4>
                        <div class="batch-options">
                            <label class="batch-option">
                                <input type="checkbox" value="tech-focused" checked>
                                <span>🔧 Technical Focus - Emphasize technical skills and architecture experience</span>
                            </label>
                            <label class="batch-option">
                                <input type="checkbox" value="leadership-focused" checked>
                                <span>👥 Leadership Focus - Highlight team management and strategic impact</span>
                            </label>
                            <label class="batch-option">
                                <input type="checkbox" value="startup-optimized">
                                <span>🚀 Startup Optimized - Fast-paced, versatile, growth-oriented</span>
                            </label>
                            <label class="batch-option">
                                <input type="checkbox" value="enterprise-optimized">
                                <span>🏢 Enterprise Optimized - Process-oriented, compliance, scale experience</span>
                            </label>
                            <label class="batch-option">
                                <input type="checkbox" value="keyword-maximized">
                                <span>🎯 ATS Keyword Maximized - Maximum job description keyword matching</span>
                            </label>
                            <label class="batch-option">
                                <input type="checkbox" value="creative-format">
                                <span>🎨 Creative Format - Alternative layout while maintaining ATS compatibility</span>
                            </label>
                        </div>
                        
                        <h4>Custom Directives</h4>
                        <textarea id="custom-directives" placeholder="Add custom testing directives (one per line):
Example: Focus on cloud architecture experience
Example: Emphasize remote work capabilities
Example: Highlight cost-saving achievements"></textarea>
                        
                        <div class="batch-controls">
                            <div class="batch-settings">
                                <label>
                                    <input type="checkbox" id="compare-mode" checked>
                                    Generate comparison dashboard after completion
                                </label>
                                <label>
                                    <input type="checkbox" id="auto-pdf" checked>
                                    Auto-generate PDFs for testing
                                </label>
                            </div>
                            <div class="batch-actions">
                                <button class="success" onclick="launchBatchTesting()">🚀 Launch Batch Testing</button>
                                <button class="secondary" onclick="hideBatchTesting()">❌ Cancel</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Batch Progress -->
                    <div id="batch-progress" style="display: none;">
                        <h4>🔄 Batch Testing Progress</h4>
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-fill" id="batch-progress-fill"></div>
                            </div>
                            <div class="progress-text" id="batch-progress-text">Initializing agents...</div>
                        </div>
                        <div id="batch-agent-status" class="agent-status-list"></div>
                    </div>
                    
                    <!-- Batch Results -->
                    <div id="batch-results" style="display: none;">
                        <h4>📊 Testing Results</h4>
                        <div id="batch-results-grid" class="batch-results-grid"></div>
                        <div class="batch-result-actions">
                            <button onclick="showBatchComparison()">📈 Compare All Variants</button>
                            <button onclick="exportBatchResults()">📄 Export Batch to PDF</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Job Manager Tab -->
            <div id="manage-jobs" class="tab-content">
                <h2>💼 Job Description Manager</h2>
                
                <div class="section">
                    <h3>📝 Create New Job Description</h3>
                    <input type="text" id="new-job-name" placeholder="Job title or identifier">
                    <textarea id="new-job-content" class="job-description-area" placeholder="Paste job description here..."></textarea>
                    <div style="margin-top: 10px;">
                        <input type="text" id="new-job-linkedin" placeholder="LinkedIn URL (optional)">
                        <button onclick="fetchLinkedInForNew()">📥 Fetch from LinkedIn</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <button onclick="saveJobDescription()">💾 Save Job</button>
                        <button onclick="saveAsMainJob()" class="success">🎯 Save as Main Target</button>
                    </div>
                </div>
                
                <div class="section">
                    <h3>📁 Saved Job Descriptions</h3>
                    <div id="saved-jobs">Loading...</div>
                </div>
            </div>
            
            <!-- Genealogy Tab -->
            <div id="genealogy" class="tab-content">
                <h2>🧬 Resume Evolution Tree</h2>
                <div id="genealogy-visualization">
                    <div>Loading genealogy tree...</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification System -->
    <div id="notification" class="notification">
        <div id="notification-content"></div>
    </div>
    
    <!-- Preview Overlay -->
    <div id="preview-overlay" class="preview-overlay">
        <div class="preview-container">
            <div class="preview-header">
                <div class="preview-title" id="preview-title">Resume Preview</div>
                <div class="preview-actions">
                    <button class="preview-download" id="preview-download" onclick="downloadPreviewedPDF()">📄 Download PDF</button>
                    <button class="preview-close" onclick="closePreview()">✕ Close</button>
                </div>
            </div>
            <div class="preview-content">
                <iframe id="preview-iframe" class="preview-iframe"></iframe>
            </div>
        </div>
    </div>
    
    <!-- Quality Control Modal -->
    <div id="quality-modal" class="quality-modal">
        <div class="quality-container">
            <div class="quality-header">
                <h3 id="quality-title">Quality Assessment</h3>
                <button class="quality-close" onclick="closeQualityModal()">✕</button>
            </div>
            <div class="quality-content">
                <div class="quality-section">
                    <h4>📊 Rate This Variant</h4>
                    <div class="rating-controls">
                        <div class="star-rating" id="star-rating">
                            <span class="star" data-rating="1">⭐</span>
                            <span class="star" data-rating="2">⭐</span>
                            <span class="star" data-rating="3">⭐</span>
                            <span class="star" data-rating="4">⭐</span>
                            <span class="star" data-rating="5">⭐</span>
                        </div>
                        <div class="rating-labels">
                            <span>Poor</span>
                            <span>Good</span>
                            <span>Excellent</span>
                        </div>
                    </div>
                </div>
                
                <div class="quality-section">
                    <h4>📝 Quality Feedback</h4>
                    <div class="feedback-checkboxes">
                        <label><input type="checkbox" value="formatting"> Poor formatting/layout</label>
                        <label><input type="checkbox" value="content"> Weak content/skills matching</label>
                        <label><input type="checkbox" value="keywords"> Missing key job keywords</label>
                        <label><input type="checkbox" value="length"> Too long/short for single page</label>
                        <label><input type="checkbox" value="ats"> Not ATS-friendly</label>
                        <label><input type="checkbox" value="focus"> Doesn't match requested focus</label>
                    </div>
                    <textarea id="quality-feedback" placeholder="Additional feedback for AI improvement..."></textarea>
                </div>
                
                <div class="quality-section">
                    <h4>🎯 Comparison with Examples</h4>
                    <div class="benchmark-section">
                        <select id="compare-template">
                            <option value="">Compare with existing high-quality variant...</option>
                        </select>
                        <button onclick="analyzeQualityGap()" class="btn-secondary">🔍 Analyze Differences</button>
                    </div>
                    <div id="quality-analysis" class="quality-analysis"></div>
                </div>
                
                <div class="quality-actions">
                    <button onclick="submitQualityFeedback()" class="btn-primary">💾 Save Feedback</button>
                    <button onclick="refinePromptFromFeedback()" class="btn-secondary">🔧 Refine AI Prompt</button>
                    <button onclick="regenerateVariant()" class="btn-success">🔄 Regenerate with Feedback</button>
                    <button onclick="deleteCurrentVariant()" class="btn-danger">🗑️ Delete Variant</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Prompt Refinement Modal -->
    <div id="prompt-modal" class="prompt-modal">
        <div class="prompt-container">
            <div class="prompt-header">
                <h3>🔧 AI Prompt Refinement</h3>
                <button class="prompt-close" onclick="closePromptModal()">✕</button>
            </div>
            <div class="prompt-content">
                <div class="prompt-section">
                    <h4>📋 Current Base Instructions</h4>
                    <textarea id="base-instructions" class="prompt-textarea">Create an ATS-optimized resume that maintains professional formatting while maximizing keyword relevance. Focus on quantifiable achievements and clear, concise descriptions. Ensure single-page layout with proper spacing and hierarchy.</textarea>
                </div>
                
                <div class="prompt-section">
                    <h4>🎯 Quality Examples Analysis</h4>
                    <div id="example-analysis" class="example-analysis">
                        <p>Analyzing your existing high-quality variants to extract patterns...</p>
                    </div>
                </div>
                
                <div class="prompt-section">
                    <h4>⚠️ Common Issues to Avoid</h4>
                    <div class="issue-patterns" id="issue-patterns">
                        <div class="issue-item">
                            <strong>Formatting Issues:</strong> <span id="formatting-issues">Loading...</span>
                        </div>
                        <div class="issue-item">
                            <strong>Content Issues:</strong> <span id="content-issues">Loading...</span>
                        </div>
                        <div class="issue-item">
                            <strong>ATS Issues:</strong> <span id="ats-issues">Loading...</span>
                        </div>
                    </div>
                </div>
                
                <div class="prompt-section">
                    <h4>✨ Refined Instructions</h4>
                    <textarea id="refined-instructions" class="prompt-textarea" placeholder="Refined instructions will appear here..."></textarea>
                </div>
                
                <div class="prompt-actions">
                    <button onclick="saveRefinedInstructions()" class="btn-primary">💾 Save Refined Instructions</button>
                    <button onclick="testRefinedPrompt()" class="btn-secondary">🧪 Test with Sample Job</button>
                    <button onclick="resetToDefaults()" class="btn-secondary">🔄 Reset to Defaults</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let creationMode = 'single';
        let selectedParents = [];
        let availableVariants = [];
        let availableJobs = [];
        let genealogyData = {};
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadInitialData();
            setInterval(updateStatus, 30000); // Update every 30 seconds
        });
        
        async function loadInitialData() {
            await Promise.all([
                loadVariants(),
                loadJobDescriptions(),
                loadGenealogyTree(),
                updateStatus()
            ]);
            
            populateParentSelectors();
            updateDashboard();
        }
        
        
        function clearSelections() {
            selectedParents = [];
            document.querySelectorAll('.parent-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            updateParentSelectionDisplay();
            updateCreationMode();
        }
        
        // Tab Management
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Hide all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // Load tab-specific data
            if (tabName === 'genealogy') {
                renderGenealogyTree();
                startStatusPolling(); // Start polling for variant status updates
            } else if (tabName === 'manage-jobs') {
                loadJobDescriptions();
            }
        }
        
        // API Functions
        async function loadVariants() {
            try {
                const response = await fetch('/api/variants');
                availableVariants = await response.json();
                updateVariantCount();
            } catch (error) {
                console.error('Error loading variants:', error);
                showNotification('Error loading variants', 'error');
            }
        }
        
        async function loadJobDescriptions() {
            try {
                const response = await fetch('/api/job-descriptions');
                availableJobs = await response.json();
                updateJobCount();
                populateJobSelector();
                updateSavedJobsList();
            } catch (error) {
                console.error('Error loading job descriptions:', error);
                showNotification('Error loading job descriptions', 'error');
            }
        }
        
        async function loadGenealogyTree() {
            try {
                const response = await fetch('/api/genealogy');
                genealogyData = await response.json();
                console.log('Genealogy data loaded:', genealogyData);
            } catch (error) {
                console.error('Error loading genealogy tree:', error);
                showNotification('Error loading genealogy tree', 'error');
            }
        }
        
        // Enhanced Parent Selection
        let currentSelectorView = 'detailed';
        let filteredParentOptions = [];
        let allParentOptions = [];
        
        function populateParentSelectors() {
            try {
                console.log('Populating parent selectors...');
                const startTime = Date.now();
                
                // Build comprehensive parent options data
                allParentOptions = [];
            
            // Add base templates
            allParentOptions.push({
                filename: 'base_resume.html',
                name: 'Original Base Template',
                generation: 0,
                type: 'Base Template',
                job: 'Universal',
                parents: [],
                created: 'Initial',
                rating: 5,
                isRecent: false,
                isBase: true
            });
            
            allParentOptions.push({
                filename: 'base_resume_v2.html',
                name: 'Enhanced Base Template',
                generation: 1,
                type: 'Evolved Base',
                job: 'Universal',
                parents: ['base_resume.html'],
                created: 'Dec 2024',
                rating: 5,
                isRecent: false,
                isBase: true
            });
            
            // Add variants with enhanced metadata
            availableVariants.forEach(variant => {
                const generation = getVariantGeneration(variant);
                const parents = determineParentNames(variant);
                const rating = getVariantRating(variant.filename);
                const jobInfo = extractJobInfo(variant);
                const createdDate = new Date(variant.created);
                const isRecent = (Date.now() - createdDate.getTime()) < (7 * 24 * 60 * 60 * 1000); // 7 days
                
                allParentOptions.push({
                    filename: variant.filename,
                    name: variant.name,
                    generation: generation,
                    type: variant.type || 'Variant',
                    job: jobInfo,
                    parents: parents,
                    created: createdDate.toLocaleDateString(),
                    rating: rating,
                    isRecent: isRecent,
                    isBase: false,
                    description: variant.description
                });
            });
            
            // Initialize filters
            populateJobFilter();
            
            // Apply initial filter and render
            filterParentOptions();
            
            const endTime = Date.now();
            console.log(`Parent selectors populated in ${endTime - startTime}ms`);
            
            } catch (error) {
                console.error('Error in populateParentSelectors:', error);
                showNotification('Error loading templates', 'error');
            }
        }
        
        function populateJobFilter() {
            const jobFilter = document.getElementById('job-filter');
            const jobs = new Set(['Universal']);
            
            allParentOptions.forEach(option => {
                if (option.job && option.job !== 'Universal') {
                    jobs.add(option.job);
                }
            });
            
            jobFilter.innerHTML = '<option value="">All Jobs</option>';
            Array.from(jobs).sort().forEach(job => {
                jobFilter.innerHTML += `<option value="${job}">${job}</option>`;
            });
        }
        
        function extractJobInfo(variant) {
            // Extract job info from variant metadata
            if (variant.job_title && variant.job_company) {
                return `${variant.job_title} @ ${variant.job_company}`;
            } else if (variant.job_title) {
                return variant.job_title;
            } else if (variant.job_company) {
                return variant.job_company;
            }
            return 'General';
        }
        
        function determineParentNames(variant) {
            // Extract parent information from variant
            if (variant.parents && variant.parents.length > 0) {
                return variant.parents;
            }
            
            // Fallback logic based on generation
            const generation = getVariantGeneration(variant);
            if (generation <= 1) {
                return ['base_resume.html'];
            } else if (variant.filename.includes('optimal')) {
                return ['base_resume_v2.html'];
            }
            return ['base_resume.html'];
        }
        
        function getVariantRating(filename) {
            const feedback = qualityFeedbackData[filename];
            return feedback ? feedback.rating : 0;
        }
        
        function switchSelectorView(view) {
            currentSelectorView = view;
            
            // Update toggle buttons
            document.querySelectorAll('.view-toggle').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            
            // Update view visibility
            document.querySelectorAll('.parent-selector-view').forEach(viewEl => {
                viewEl.classList.toggle('active', viewEl.id === view + '-selector');
            });
            
            // Render current view
            if (view === 'detailed') {
                renderDetailedView();
            } else {
                renderTreeView();
            }
        }
        
        function filterParentOptions() {
            const jobFilter = document.getElementById('job-filter').value;
            const generationFilter = document.getElementById('generation-filter').value;
            
            filteredParentOptions = allParentOptions.filter(option => {
                // Job filter
                if (jobFilter && option.job !== jobFilter) {
                    return false;
                }
                
                // Generation filter
                if (generationFilter) {
                    const filterGen = parseInt(generationFilter);
                    if (filterGen === 3) {
                        // 3+ generations
                        if (option.generation < 3) return false;
                    } else {
                        if (option.generation !== filterGen) return false;
                    }
                }
                
                return true;
            });
            
            // Re-render current view
            if (currentSelectorView === 'detailed') {
                renderDetailedView();
            } else {
                renderTreeView();
            }
        }
        
        function renderDetailedView() {
            const grid = document.getElementById('parent-cards-grid');
            
            let html = '';
            filteredParentOptions.forEach(option => {
                const isSelected = selectedParents.includes(option.filename);
                const selectedClass = isSelected ? 'selected' : '';
                
                // Enhanced badges with better styling
                let badges = `<span class="gen-badge gen-${option.generation}">Gen ${option.generation}</span>`;
                if (option.isRecent) {
                    badges += `<span class="recent-badge">New</span>`;
                }
                if (option.parents && option.parents.length > 1) {
                    badges += `<span class="hybrid-badge">🧬 Hybrid</span>`;
                }
                
                // Clean lineage display
                let lineageInfo = '';
                if (option.parents && option.parents.length > 0) {
                    const parentNames = option.parents.map(p => getShortName(p)).join(' + ');
                    lineageInfo = `<div class="lineage">← ${parentNames}</div>`;
                }
                
                // Job/type indicator
                const jobDisplay = option.job || option.type || 'General';
                
                html += `
                    <div class="parent-card ${selectedClass}" data-filename="${option.filename}" onclick="handleParentSelection('${option.filename}')">
                        <div class="card-top">
                            <div class="card-title">${option.name}</div>
                            <div class="card-badges">${badges}</div>
                        </div>
                        <div class="card-meta">
                            <div class="job-type">${jobDisplay}</div>
                            ${lineageInfo}
                        </div>
                        <div class="card-actions">
                            <button class="preview-btn" onclick="event.stopPropagation(); previewParent('${option.filename}', '${option.name}')">👁️ Preview</button>
                            <span class="creation-date">${option.created}</span>
                        </div>
                    </div>
                `;
            });
            
            if (html === '') {
                html = '<div class="no-results">No templates match the current filters.</div>';
            }
            
            grid.innerHTML = html;
        }
        
        function renderTreeView() {
            const tree = document.getElementById('horizontal-tree');
            
            // Simple flat view with parent relationships shown
            let html = '';
            
            // Group by generation for simple display
            const generations = {};
            filteredParentOptions.forEach(option => {
                if (!generations[option.generation]) {
                    generations[option.generation] = [];
                }
                generations[option.generation].push(option);
            });
            
            Object.keys(generations).sort((a, b) => parseInt(a) - parseInt(b)).forEach(gen => {
                const genNumber = parseInt(gen);
                const items = generations[gen];
                
                html += `
                    <div class="tree-generation">
                        <div class="tree-gen-label">Generation ${genNumber}</div>
                        <div class="tree-gen-items">
                `;
                
                items.forEach(option => {
                    const isSelected = selectedParents.includes(option.filename);
                    const selectedClass = isSelected ? 'selected' : '';
                    const parentInfo = option.parents && option.parents.length > 0 ? 
                        `← ${option.parents.map(p => getShortName(p)).join(', ')}` : '';
                    const hybridIcon = option.parents && option.parents.length > 1 ? ' 🧬' : '';
                    
                    html += `
                        <div class="tree-node ${selectedClass}" data-filename="${option.filename}" onclick="handleParentSelection('${option.filename}')">
                            <div class="tree-node-title">${option.name}${hybridIcon}</div>
                            <div class="tree-node-job">${option.job || option.type}</div>
                            <div class="tree-node-parent">${parentInfo}</div>
                            <div class="tree-node-preview">
                                <button class="tree-preview-btn" onclick="event.stopPropagation(); previewParent('${option.filename}', '${option.name}')">👁️</button>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            if (html === '') {
                html = '<div style="text-align: center; padding: 40px; color: #666;">No templates match the current filters.</div>';
            }
            
            tree.innerHTML = html;
        }
        
        
        function getShortName(filename) {
            const option = allParentOptions.find(opt => opt.filename === filename);
            if (option) {
                return option.name.length > 20 ? option.name.substring(0, 20) + '...' : option.name;
            }
            return filename.replace('.html', '');
        }
        
        function handleParentSelection(filename) {
            const isSelected = selectedParents.includes(filename);
            
            if (isSelected) {
                // Deselect
                selectedParents = selectedParents.filter(p => p !== filename);
            } else {
                // Select (max 4 parents)
                if (selectedParents.length < 4) {
                    selectedParents.push(filename);
                } else {
                    showNotification('Maximum 4 parents allowed', 'warning');
                    return;
                }
            }
            
            // Update displays
            updateParentSelectionDisplay();
            updateCreationMode();
            
            // Re-render current view to update selection state
            if (currentSelectorView === 'detailed') {
                renderDetailedView();
            } else {
                renderTreeView();
            }
        }
        
        function previewParent(filename, name) {
            const url = `http://localhost:8081/agent_workspace/variants/${filename}`;
            showPreview(url, name);
        }
        
        function updateParentSelectionDisplay() {
            const countDisplay = document.getElementById('selected-count');
            const templatesDisplay = document.getElementById('selected-templates-display');
            
            countDisplay.textContent = selectedParents.length;
            
            // Create template tags
            let tagsHtml = '';
            selectedParents.forEach(filename => {
                const option = allParentOptions.find(opt => opt.filename === filename);
                const name = option ? option.name : filename;
                const shortName = name.length > 15 ? name.substring(0, 15) + '...' : name;
                
                tagsHtml += `
                    <div class="selected-template-tag">
                        ${shortName}
                        <span class="remove" onclick="removeSelectedParent('${filename}')">×</span>
                    </div>
                `;
            });
            
            templatesDisplay.innerHTML = tagsHtml;
        }
        
        function removeSelectedParent(filename) {
            selectedParents = selectedParents.filter(p => p !== filename);
            updateParentSelectionDisplay();
            updateCreationMode();
            
            // Re-render current view
            if (currentSelectorView === 'detailed') {
                renderDetailedView();
            } else {
                renderTreeView();
            }
        }
        
        function updateCreationMode() {
            const modeIndicator = document.getElementById('mode-indicator');
            const descriptionField = document.getElementById('variant-description');
            const createButton = document.getElementById('create-button');
            const agentCommandSection = document.getElementById('agent-command-section');
            
            if (selectedParents.length === 0) {
                modeIndicator.textContent = '';
                modeIndicator.className = 'mode-indicator';
                createButton.disabled = true;
                createButton.textContent = 'Select Parent(s)';
                agentCommandSection.style.display = 'none';
            } else if (selectedParents.length === 1) {
                modeIndicator.textContent = '📄 Single Variant Mode - AI Enhancement';
                modeIndicator.className = 'mode-indicator single';
                descriptionField.style.display = 'none';
                agentCommandSection.style.display = 'block';
                createButton.disabled = false;
                createButton.textContent = '🚀 Generate Variant';
                creationMode = 'single';
            } else {
                modeIndicator.textContent = '🔀 Hybrid Merge Mode';
                modeIndicator.className = 'mode-indicator hybrid';
                descriptionField.style.display = 'block';
                agentCommandSection.style.display = 'none';
                createButton.disabled = false;
                createButton.textContent = '🧬 Create Hybrid';
                creationMode = 'hybrid';
            }
        }
        
        // Job Description Management
        function populateJobSelector() {
            const selector = document.getElementById('job-selector');
            let html = '<option value="">Create new job description...</option>';
            
            availableJobs.forEach(job => {
                const activeLabel = job.active ? ' (ACTIVE)' : '';
                html += `<option value="${job.filename}">${job.title} - ${job.company}${activeLabel}</option>`;
            });
            
            selector.innerHTML = html;
        }
        
        async function loadJobDescription() {
            const selector = document.getElementById('job-selector');
            const textarea = document.getElementById('job-description');
            const selectedJob = availableJobs.find(job => job.filename === selector.value);
            
            if (selectedJob) {
                try {
                    // Try to load the full content from the file
                    const response = await fetch(`/agent_workspace/job_descriptions/${selectedJob.filename}`);
                    if (response.ok) {
                        const content = await response.text();
                        textarea.value = content;
                        originalJobContent = content;
                    } else {
                        // Fallback to preview content
                        const fallbackContent = selectedJob.preview.replace('...', '\\n\\n[Full content - please edit as needed]');
                        textarea.value = fallbackContent;
                        originalJobContent = fallbackContent;
                    }
                } catch (error) {
                    const fallbackContent = selectedJob.preview.replace('...', '\\n\\n[Full content - please edit as needed]');
                    textarea.value = fallbackContent;
                    originalJobContent = fallbackContent;
                }
                
                // Set state for existing job
                isExistingJob = true;
                hasUserContent = false;
                hasLinkedInContent = false;
                currentJobName = `${selectedJob.title} - ${selectedJob.company}`;
                lastSavedJobName = currentJobName;
                // Expand with LinkedIn hidden and no save button initially
                expandJobDescription(true, false);
                updateJobStepTitle();
            } else {
                // Creating new job description
                textarea.value = '';
                originalJobContent = '';
                isExistingJob = false;
                hasUserContent = false;
                hasLinkedInContent = false;
                currentJobName = '';
                lastSavedJobName = '';
                collapseJobDescription();
                updateJobStepTitle();
            }
        }
        
        async function fetchLinkedInJob() {
            const url = document.getElementById('linkedin-url').value;
            if (!url) {
                showNotification('Please enter a LinkedIn URL', 'warning');
                return;
            }
            
            try {
                showNotification('Fetching LinkedIn job details...', 'info');
                const response = await fetch(`/api/fetch-linkedin?url=${encodeURIComponent(url)}`);
                const result = await response.json();
                
                if (result.success) {
                    document.getElementById('job-description').value = result.content;
                    originalJobContent = '';
                    isExistingJob = false;
                    hasUserContent = false; // LinkedIn fetch is not user content
                    hasLinkedInContent = true; // Mark as LinkedIn content
                    expandJobDescription(false, true, true); // Show LinkedIn, show save, minimize LinkedIn
                    
                    // Show what was extracted
                    if (result.title && result.title !== 'Software Engineer') {
                        showNotification(`Extracted: "${result.title}" at ${result.company || 'Target Company'}`, 'success');
                    } else {
                        showNotification('LinkedIn template created - please paste full job description', 'warning');
                    }
                } else {
                    document.getElementById('job-description').value = result.template || result.message;
                    originalJobContent = '';
                    isExistingJob = false;
                    hasUserContent = false; // LinkedIn fetch is not user content
                    hasLinkedInContent = true; // Mark as LinkedIn content (even template)
                    expandJobDescription(false, true, true); // Show LinkedIn, show save, minimize LinkedIn
                    showNotification('LinkedIn template provided - please edit with actual content', 'warning');
                }
                
                // Clear the URL field after processing
                document.getElementById('linkedin-url').value = '';
            } catch (error) {
                showNotification('Error fetching LinkedIn job', 'error');
            }
        }
        
        async function fetchLinkedInForNew() {
            const url = document.getElementById('new-job-linkedin').value;
            if (!url) {
                showNotification('Please enter a LinkedIn URL', 'warning');
                return;
            }
            
            try {
                showNotification('Fetching LinkedIn job details...', 'info');
                const response = await fetch(`/api/fetch-linkedin?url=${encodeURIComponent(url)}`);
                const result = await response.json();
                
                if (result.success) {
                    document.getElementById('new-job-content').value = result.content;
                    
                    // Auto-fill job name with extracted info
                    if (result.title && result.company && result.title !== 'Software Engineer') {
                        document.getElementById('new-job-name').value = `${result.title} - ${result.company}`;
                        showNotification(`Extracted: "${result.title}" at ${result.company}, ${result.location}`, 'success');
                    } else if (result.title) {
                        document.getElementById('new-job-name').value = result.title;
                        showNotification('LinkedIn job details extracted - please paste full description', 'success');
                    } else {
                        showNotification('LinkedIn template created - please paste full job description', 'warning');
                    }
                } else {
                    document.getElementById('new-job-content').value = result.template || result.message;
                    showNotification('LinkedIn template provided - please edit with actual content', 'warning');
                }
                
                // Clear the URL field after processing
                document.getElementById('new-job-linkedin').value = '';
            } catch (error) {
                showNotification('Error fetching LinkedIn job', 'error');
            }
        }
        
        async function saveCurrentJobDescription() {
            const content = document.getElementById('job-description').value;
            if (!content.trim()) {
                showNotification('No job description to save', 'warning');
                return;
            }
            
            const name = prompt('Enter a name for this job description:');
            if (!name) return;
            
            try {
                const response = await fetch('/api/save-job-description', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        content: content,
                        is_main: false
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showNotification('Job description saved', 'success');
                    lastSavedJobName = name;
                    currentJobName = name;
                    updateJobStepTitle();
                    loadJobDescriptions();
                } else {
                    showNotification('Error saving job description', 'error');
                }
            } catch (error) {
                showNotification('Error saving job description', 'error');
            }
        }
        
        async function saveJobDescription() {
            const name = document.getElementById('new-job-name').value;
            const content = document.getElementById('new-job-content').value;
            
            if (!content.trim()) {
                showNotification('Please enter job description content', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/api/save-job-description', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        content: content,
                        is_main: false
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showNotification('Job description saved', 'success');
                    loadJobDescriptions();
                    document.getElementById('new-job-name').value = '';
                    document.getElementById('new-job-content').value = '';
                } else {
                    showNotification('Error saving job description', 'error');
                }
            } catch (error) {
                showNotification('Error saving job description', 'error');
            }
        }
        
        async function saveAsMainJob() {
            const content = document.getElementById('new-job-content').value;
            
            if (!content.trim()) {
                showNotification('Please enter job description content', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/api/save-job-description', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: content,
                        is_main: true
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showNotification('Saved as main target job', 'success');
                    loadJobDescriptions();
                    document.getElementById('new-job-content').value = '';
                } else {
                    showNotification('Error saving main job', 'error');
                }
            } catch (error) {
                showNotification('Error saving main job', 'error');
            }
        }
        
        // Resume Creation
        async function createResume() {
            const jobDescription = document.getElementById('job-description').value;
            
            if (selectedParents.length === 0) {
                showNotification('Please select at least one parent template', 'warning');
                return;
            }
            
            if (selectedParents.length === 1) {
                await createVariant();
            } else {
                await createHybrid();
            }
        }
        
        async function createVariant() {
            const jobDescription = document.getElementById('job-description').value;
            const variantName = document.getElementById('variant-name').value;
            const focusType = document.getElementById('focus-type').value;
            const agentCommand = document.getElementById('agent-command').value;
            const generationNotes = document.getElementById('generation-notes').value;
            
            try {
                showNotification('Creating variant...', 'info');
                
                // Combine job description with generation notes
                let fullJobDescription = jobDescription || 'General job-agnostic optimization';
                if (generationNotes) {
                    fullJobDescription += `\n\nAdditional Instructions: ${generationNotes}`;
                }
                
                // Use the same format as batch generation
                const response = await fetch('/api/create-variant', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        parent_template: selectedParents[0],
                        job_description: fullJobDescription,
                        focus_type: agentCommand || focusType || 'optimize',
                        batch_mode: true,  // Use batch mode processing like successful batch tests
                        strategy_focus: getStrategyDescription(agentCommand || focusType || 'optimize'),
                        variant_name: variantName
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showNotification(`Variant created: ${result.variant_name}`, 'success');
                    const previewUrl = `http://localhost:8081${result.preview_url}`;
                    showVariantResult(result.variant_name, previewUrl, result.analysis);
                    // Reload variants without full page reload to prevent lockup
                    await loadVariants();
                    populateParentSelectors();
                    filterParentOptions();
                } else {
                    showNotification('Error creating variant', 'error');
                }
            } catch (error) {
                showNotification('Error creating variant', 'error');
            }
        }
        
        async function createHybrid() {
            const jobDescription = document.getElementById('job-description').value;
            const hybridName = document.getElementById('variant-name').value;
            const description = document.getElementById('variant-description').value;
            
            try {
                showNotification('Creating hybrid variant...', 'info');
                
                const response = await fetch('/api/create-hybrid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        parents: selectedParents,
                        hybrid_name: hybridName,
                        job_description: jobDescription || 'Job-agnostic hybrid variant',
                        description: description
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showNotification(`Hybrid created: ${result.hybrid_name}`, 'success');
                    const previewUrl = `http://localhost:8081${result.preview_url}`;
                    showVariantResult(result.hybrid_name, previewUrl, {parents: result.parents});
                    // Reload variants without full page reload to prevent lockup
                    await loadVariants();
                    populateParentSelectors();
                    filterParentOptions();
                } else {
                    showNotification('Error creating hybrid', 'error');
                }
            } catch (error) {
                showNotification('Error creating hybrid', 'error');
            }
        }
        
        // PDF Export
        async function exportToPDF(variantName) {
            try {
                showNotification('Generating PDF...', 'info');
                
                // First, trigger PDF generation on the server
                const convertResponse = await fetch('/api/convert-to-pdf', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        variant_name: variantName
                    })
                });
                
                const convertResult = await convertResponse.json();
                
                if (convertResult.success) {
                    // PDF was generated successfully, now download it
                    const pdfFilename = variantName.replace('.html', '') + '.pdf';
                    const downloadUrl = `/agent_workspace/output/${pdfFilename}`;
                    
                    // Create download link
                    const link = document.createElement('a');
                    link.href = downloadUrl;
                    link.download = pdfFilename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    showNotification('PDF downloaded successfully!', 'success');
                } else {
                    throw new Error(convertResult.message || 'PDF conversion failed');
                }
            } catch (error) {
                console.error('PDF export error:', error);
                showNotification('Error generating PDF: ' + error.message, 'error');
            }
        }
        
        async function exportBothToPDF(parentFilename, childFilename) {
            try {
                showNotification('Generating comparison PDFs...', 'info');
                
                // Export both PDFs
                await exportToPDF(parentFilename);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Small delay
                await exportToPDF(childFilename);
                
                showNotification('Both PDFs downloaded successfully!', 'success');
            } catch (error) {
                console.error('Error exporting comparison PDFs:', error);
                showNotification('Error generating comparison PDFs', 'error');
            }
        }
        
        // UI Helper Functions
        function showVariantResult(variantName, previewUrl, analysis) {
            const resultHtml = `
                <div class="variant-preview">
                    <div class="variant-header">
                        <span class="variant-title">${variantName}</span>
                        <span class="variant-badge">New</span>
                    </div>
                    <div class="variant-content">
                        <p>Resume created successfully!</p>
                        <div class="variant-actions">
                            <button onclick="showPreview('${previewUrl}', '${variantName}')">👁️ Preview</button>
                            <button onclick="exportToPDF('${variantName}')" class="success">📄 Export PDF</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert at top of current tab
            const activeTab = document.querySelector('.tab-content.active');
            activeTab.insertAdjacentHTML('afterbegin', resultHtml);
        }
        
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            const content = document.getElementById('notification-content');
            
            content.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }
        
        function updateStatus() {
            updateVariantCount();
            updateJobCount();
        }
        
        function updateVariantCount() {
            document.getElementById('variant-count').textContent = availableVariants.length;
            const headerCount = document.getElementById('header-variant-count');
            if (headerCount) headerCount.textContent = availableVariants.length;
        }
        
        function updateJobCount() {
            document.getElementById('job-count').textContent = availableJobs.length;
            const headerCount = document.getElementById('header-job-count');
            if (headerCount) headerCount.textContent = availableJobs.length;
        }
        
        function updateDashboard(searchTerm = '') {
            const dashboard = document.getElementById('variants-dashboard');
            const searchStatus = document.getElementById('search-status');
            
            // Filter variants based on search term
            let filteredVariants = availableVariants;
            if (searchTerm) {
                searchTerm = searchTerm.toLowerCase();
                filteredVariants = availableVariants.filter(variant => {
                    return (
                        variant.name.toLowerCase().includes(searchTerm) ||
                        variant.description.toLowerCase().includes(searchTerm) ||
                        variant.type.toLowerCase().includes(searchTerm) ||
                        (variant.job_title && variant.job_title.toLowerCase().includes(searchTerm)) ||
                        (variant.job_company && variant.job_company.toLowerCase().includes(searchTerm))
                    );
                });
            }
            
            // Sort variants with hierarchy and recency
            const sortedVariants = sortVariantsWithHierarchy(filteredVariants);
            
            // Track recently created variants (last 5 minutes)
            const now = Date.now();
            const recentThreshold = 5 * 60 * 1000; // 5 minutes
            
            // Update search status
            if (searchTerm) {
                searchStatus.textContent = `Found ${filteredVariants.length} of ${availableVariants.length} variants`;
            } else {
                searchStatus.textContent = `Showing all ${availableVariants.length} variants`;
            }
            
            let html = '<div class="variant-grid-enhanced">';
            
            sortedVariants.forEach(variant => {
                const hybridBadge = variant.is_hybrid ? ' 🧬' : '';
                const jobInfo = (variant.job_title || variant.job_company) ? 
                    `<div class="variant-job-info">
                        ${variant.job_title ? `🎯 ${variant.job_title}` : ''} 
                        ${variant.job_company ? `@ ${variant.job_company}` : ''}
                    </div>` : '';
                
                // Check if this is a recently created variant
                const variantTime = variant.created ? new Date(variant.created).getTime() : 0;
                const isRecent = (now - variantTime) < recentThreshold;
                
                // Generate enhanced badges
                const preferenceBadges = generatePreferenceBadges(variant);
                const newBadge = isRecent ? '<span class="badge-new">NEW</span>' : '';
                const generationIndicator = generateGenerationIndicator(variant);
                const parentInfo = generateParentInfo(variant);
                
                // Get creation time info
                const createdInfo = getCreationTimeInfo(variant);
                
                html += `
                    <div class="variant-card-compact ${getVariantPriorityClass(variant)} ${isRecent ? 'is-recent' : ''}">
                        <div class="variant-card-header">
                            <div class="variant-title-row">
                                <span class="variant-title-compact">${variant.name}${hybridBadge}</span>
                                <div class="badges-row">
                                    ${newBadge}
                                    ${preferenceBadges}
                                </div>
                            </div>
                            <div class="variant-meta-row">
                                ${generationIndicator}
                                ${parentInfo}
                                <span class="variant-type-compact ${variant.is_hybrid ? 'hybrid' : ''}">${variant.type}</span>
                                <span class="variant-time-compact">${createdInfo}</span>
                            </div>
                        </div>
                        <div class="variant-card-content">
                            <p class="variant-description-compact">${variant.description}</p>
                            ${jobInfo}
                        </div>
                        <div class="variant-card-actions">
                            <button onclick="showPreview('http://localhost:8081/agent_workspace/variants/${variant.filename}', '${variant.name}')" class="btn-compact preview">👁️</button>
                            <button onclick="exportToPDF('${variant.filename}')" class="btn-compact export">📄</button>
                            ${variant.parent ? `<button onclick="showComparison('${variant.filename}', '${variant.parent}')" class="btn-compact compare" title="Compare with parent">🔍</button>` : ''}
                            <button onclick="setAsPreferred('${variant.filename}')" class="btn-compact star">⭐</button>
                            <button onclick="showQualityControls('${variant.filename}', '${variant.name}')" class="btn-compact quality">📊</button>
                            <button onclick="deleteVariant('${variant.filename}', '${variant.name}')" class="btn-compact delete">🗑️</button>
                        </div>
                    </div>
                `;
            });
            
            if (sortedVariants.length === 0) {
                html += '<div class="empty-state">No variants found matching your search.</div>';
            }
            
            html += '</div>';
            dashboard.innerHTML = html;
        }
        
        function sortVariantsWithHierarchy(variants) {
            // Sort by: 1. Preferred status, 2. Generation (higher = more recent), 3. Creation time
            return variants.sort((a, b) => {
                // Global preferred first
                const aGlobalPref = isGlobalPreferred(a);
                const bGlobalPref = isGlobalPreferred(b);
                if (aGlobalPref !== bGlobalPref) return bGlobalPref - aGlobalPref;
                
                // Job-specific preferred next
                const aJobPref = isJobPreferred(a);
                const bJobPref = isJobPreferred(b);
                if (aJobPref !== bJobPref) return bJobPref - aJobPref;
                
                // Higher generation (more evolved) next
                const aGen = getVariantGeneration(a);
                const bGen = getVariantGeneration(b);
                if (aGen !== bGen) return bGen - aGen;
                
                // Most recent creation time last
                const aTime = new Date(a.created);
                const bTime = new Date(b.created);
                return bTime - aTime;
            });
        }
        
        function generatePreferenceBadges(variant) {
            let badges = '';
            
            if (isGlobalPreferred(variant)) {
                badges += '<span class="preference-badge global">🌟 Global</span>';
            }
            
            if (isJobPreferred(variant)) {
                badges += '<span class="preference-badge job">🎯 Job</span>';
            }
            
            if (isBaseTemplate(variant)) {
                badges += '<span class="preference-badge base">🏗️ Base</span>';
            }
            
            return badges;
        }
        
        function generateGenerationIndicator(variant) {
            const generation = getVariantGeneration(variant);
            const evolutionStage = getEvolutionStage(generation);
            
            return `<span class="generation-indicator gen-${generation}">
                ${evolutionStage.icon} Gen ${generation}
            </span>`;
        }
        
        function getEvolutionStage(generation) {
            const stages = {
                0: { icon: '🌱', name: 'Original' },
                1: { icon: '🌿', name: 'Evolved' },
                2: { icon: '🌳', name: 'Optimized' },
                3: { icon: '🔥', name: 'Advanced' },
                4: { icon: '⚡', name: 'Elite' }
            };
            
            return stages[generation] || { icon: '🚀', name: 'Ultra' };
        }
        
        function getCreationTimeInfo(variant) {
            const created = new Date(variant.created);
            const now = new Date();
            const diffHours = Math.floor((now - created) / (1000 * 60 * 60));
            
            if (diffHours < 1) return 'Just now';
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffHours < 168) return `${Math.floor(diffHours / 24)}d ago`;
            return created.toLocaleDateString();
        }
        
        function getVariantPriorityClass(variant) {
            if (isGlobalPreferred(variant)) return 'priority-global';
            if (isJobPreferred(variant)) return 'priority-job';
            if (getVariantGeneration(variant) >= 3) return 'priority-advanced';
            return 'priority-normal';
        }
        
        function generateParentInfo(variant) {
            if (!variant.parent) return '';
            
            // Get parent name for display
            const parentName = variant.parent.replace('.html', '').replace(/^base_/, '');
            
            return `<span class="parent-info" title="Child of ${parentName}">
                📁 ${parentName}
            </span>`;
        }
        
        function showComparison(childFilename, parentFilename) {
            // Open comparison modal/window
            const modal = document.createElement('div');
            modal.className = 'comparison-modal';
            modal.innerHTML = `
                <div class="comparison-content">
                    <div class="comparison-header">
                        <h3>Compare Variants</h3>
                        <button onclick="this.closest('.comparison-modal').remove()" class="close-btn">✕</button>
                    </div>
                    <div class="comparison-body">
                        <div class="comparison-side">
                            <h4>Parent: ${parentFilename.replace('.html', '')}</h4>
                            <iframe src="http://localhost:8081/agent_workspace/variants/${parentFilename}" 
                                style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px;"></iframe>
                        </div>
                        <div class="comparison-side">
                            <h4>Child: ${childFilename.replace('.html', '')}</h4>
                            <iframe src="http://localhost:8081/agent_workspace/variants/${childFilename}" 
                                style="width: 100%; height: 400px; border: 1px solid #ddd; border-radius: 4px;"></iframe>
                        </div>
                    </div>
                    <div class="comparison-actions">
                        <button onclick="exportBothToPDF('${parentFilename}', '${childFilename}')" class="btn-primary">
                            📄 Export Both PDFs
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function getVariantGeneration(variant, visited = new Set()) {
            // Prevent infinite recursion
            if (visited.has(variant.filename)) {
                console.warn('Circular dependency detected for', variant.filename);
                return 1; // Safe fallback
            }
            visited.add(variant.filename);
            
            try {
                // First try to get generation from API if available
                if (variant.generation !== undefined && variant.generation !== null) {
                    return variant.generation;
                }
                
                // Extract generation from filename patterns
                const genMatch = variant.filename.match(/gen(\d+)|__gen(\d+)/);
                if (genMatch) return parseInt(genMatch[1] || genMatch[2]);
                
                // Calculate based on parents if available
                if (variant.parents && variant.parents.length > 0) {
                    let maxParentGen = 0;
                    variant.parents.forEach(parentName => {
                        if (visited.has(parentName)) {
                            console.warn('Skipping circular parent', parentName);
                            return;
                        }
                        
                        const parentOption = allParentOptions.find(opt => opt.filename === parentName);
                        if (parentOption) {
                            const parentGen = getVariantGeneration(parentOption, new Set(visited));
                            maxParentGen = Math.max(maxParentGen, parentGen);
                        } else if (parentName === 'base_resume.html') {
                            maxParentGen = Math.max(maxParentGen, 0);
                        } else if (parentName === 'base_resume_v2.html') {
                            maxParentGen = Math.max(maxParentGen, 1);
                        }
                    });
                    return maxParentGen + 1;
                }
                
                // Fallback based on known patterns
                if (variant.filename === 'base_resume.html') return 0;
                if (variant.filename === 'base_resume_v2.html') return 1;
                if (variant.filename.includes('optimal')) return 2;
                
                return 1; // Default for unknown variants
            } catch (error) {
                console.error('Error calculating generation for', variant.filename, error);
                return 1; // Safe fallback
            }
        }
        
        // Preference management functions
        function isGlobalPreferred(variant) {
            return localStorage.getItem('globalPreferred') === variant.filename;
        }
        
        function isJobPreferred(variant) {
            const currentJob = getCurrentJobContext();
            return localStorage.getItem(`jobPreferred_${currentJob}`) === variant.filename;
        }
        
        function isBaseTemplate(variant) {
            return variant.filename.includes('base_resume');
        }
        
        function getCurrentJobContext() {
            // Determine current job context from job description
            const jobDesc = document.getElementById('job-description').value;
            if (!jobDesc.trim()) return 'default';
            
            // Simple hash of job description to create consistent context
            return btoa(jobDesc.substring(0, 100)).replace(/[^a-zA-Z0-9]/g, '').substring(0, 10);
        }
        
        function setAsPreferred(filename) {
            const currentJob = getCurrentJobContext();
            
            // Show preference options
            const options = [
                { label: '🌟 Set as Global Preferred', action: () => {
                    localStorage.setItem('globalPreferred', filename);
                    showNotification('Set as global preferred template');
                    updateDashboard();
                }},
                { label: '🎯 Set as Job Preferred', action: () => {
                    localStorage.setItem(`jobPreferred_${currentJob}`, filename);
                    showNotification('Set as preferred for this job');
                    updateDashboard();
                }},
                { label: '❌ Remove Preferences', action: () => {
                    localStorage.removeItem('globalPreferred');
                    localStorage.removeItem(`jobPreferred_${currentJob}`);
                    showNotification('Preferences cleared');
                    updateDashboard();
                }}
            ];
            
            showPreferenceMenu(options);
        }
        
        function showPreferenceMenu(options) {
            // Create a simple popup menu
            const menu = document.createElement('div');
            menu.className = 'preference-menu';
            menu.innerHTML = options.map(opt => 
                `<button onclick="this.parentElement.remove(); (${opt.action.toString()})()">${opt.label}</button>`
            ).join('');
            
            // Position near cursor
            menu.style.position = 'fixed';
            menu.style.top = '50%';
            menu.style.left = '50%';
            menu.style.transform = 'translate(-50%, -50%)';
            menu.style.zIndex = '10000';
            
            document.body.appendChild(menu);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (menu.parentElement) menu.remove();
            }, 10000);
        }
        
        function updateSavedJobsList() {
            const savedJobs = document.getElementById('saved-jobs');
            
            let html = '';
            availableJobs.forEach(job => {
                const activeLabel = job.active ? ' (ACTIVE)' : '';
                html += `
                    <div class="variant-preview">
                        <div class="variant-header">
                            <span class="variant-title">${job.title} - ${job.company}${activeLabel}</span>
                            <span class="variant-badge">${new Date(job.created).toLocaleDateString()}</span>
                        </div>
                        <div class="variant-content">
                            <p>${job.preview}</p>
                            <div class="variant-actions">
                                <button onclick="loadJobToEditor('${job.filename}')">📝 Edit</button>
                                <button onclick="deleteJob('${job.filename}')" class="danger">🗑️ Delete</button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            if (html === '') {
                html = '<div>No saved job descriptions yet. Create one above!</div>';
            }
            
            savedJobs.innerHTML = html;
        }
        
        function renderGenealogyTree() {
            const container = document.getElementById('genealogy-visualization');
            
            // Create enhanced card-based tree with minimap
            container.innerHTML = `
                <div class="tree-container">
                    <div class="tree-minimap" id="tree-minimap">
                        <div class="minimap-header">
                            <h4>Genealogy Overview</h4>
                            <div class="minimap-controls">
                                <button onclick="focusOnRecent()" class="minimap-btn">📍 Recent</button>
                                <button onclick="resetTreeView()" class="minimap-btn">🏠 Reset</button>
                            </div>
                        </div>
                        <div class="minimap-content">
                            <div class="minimap-viewport" id="minimap-viewport"></div>
                            <svg class="minimap-svg" id="minimap-svg"></svg>
                        </div>
                    </div>
                    <div class="tree-main-view" id="tree-main">
                        <div class="tree-canvas" id="tree-canvas"></div>
                    </div>
                </div>
            `;
            
            const treeCanvas = document.getElementById('tree-canvas');
            const minimap = document.getElementById('tree-minimap');
            const minimapSvg = document.getElementById('minimap-svg');
            
            // Build node hierarchy
            const nodes = [];
            const nodeMap = {};
            const generations = {};
            
            // Process all variants into node data
            Object.keys(genealogyData).forEach(key => {
                const data = genealogyData[key];
                const node = {
                    key: key,
                    name: data.info.name,
                    generation: data.info.generation,
                    type: data.info.type,
                    description: data.info.description,
                    is_hybrid: data.info.is_hybrid,
                    parents: data.info.parents || [],
                    children: data.children || [],
                    job_title: data.info.job_title || '',
                    job_company: data.info.job_company || '',
                    created: data.info.created || '',
                    x: 0,
                    y: 0
                };
                nodes.push(node);
                nodeMap[key] = node;
                
                // Group by generation
                if (!generations[node.generation]) {
                    generations[node.generation] = [];
                }
                generations[node.generation].push(node);
            });
            
            // Calculate card positions using parent-child hierarchy
            const cardWidth = 280;
            const cardHeight = 120;
            const verticalGap = 150;
            const horizontalGap = 20;
            const childIndent = 30; // Indent children slightly from parents
            
            // Build hierarchical tree structure
            const rootNodes = nodes.filter(node => !node.parents || node.parents.length === 0);
            const positionedNodes = new Set();
            let currentY = 20;
            let maxX = 0;
            
            // Position nodes hierarchically
            function positionNodeAndChildren(node, x, y, parentWidth = 0) {
                if (positionedNodes.has(node.key)) return { width: 0, height: 0 };
                
                // Position current node
                node.x = x;
                node.y = y;
                positionedNodes.add(node.key);
                
                // Find direct children of this node and sort by creation time (newest first)
                const children = nodes.filter(child => 
                    child.parents && child.parents.includes(node.key) && !positionedNodes.has(child.key)
                ).sort((a, b) => {
                    // Sort by creation time, newest first (but keep hierarchical grouping)
                    const aTime = a.created ? new Date(a.created).getTime() : 0;
                    const bTime = b.created ? new Date(b.created).getTime() : 0;
                    return bTime - aTime; // Newest first within the same parent
                });
                
                if (children.length === 0) {
                    // Leaf node
                    maxX = Math.max(maxX, x + cardWidth);
                    return { width: cardWidth, height: cardHeight };
                }
                
                // Position children below this node
                let childX = x + childIndent;
                let childY = y + verticalGap;
                let totalChildWidth = 0;
                let maxChildHeight = 0;
                
                children.forEach((child, i) => {
                    const childDimensions = positionNodeAndChildren(child, childX, childY, cardWidth);
                    childX += childDimensions.width + horizontalGap;
                    totalChildWidth += childDimensions.width + (i < children.length - 1 ? horizontalGap : 0);
                    maxChildHeight = Math.max(maxChildHeight, childDimensions.height);
                });
                
                // Center parent over children if children are wider
                if (totalChildWidth > cardWidth) {
                    const centerOffset = (totalChildWidth - cardWidth) / 2;
                    node.x = x + centerOffset;
                    maxX = Math.max(maxX, x + totalChildWidth);
                } else {
                    maxX = Math.max(maxX, x + cardWidth);
                }
                
                return { 
                    width: Math.max(cardWidth, totalChildWidth), 
                    height: cardHeight + verticalGap + maxChildHeight 
                };
            }
            
            // Position each root node and its descendants
            let rootX = 20;
            rootNodes.forEach(rootNode => {
                const treeDimensions = positionNodeAndChildren(rootNode, rootX, currentY);
                rootX += treeDimensions.width + horizontalGap * 2; // Extra space between root trees
            });
            
            // Handle any orphaned nodes (shouldn't happen but just in case)
            const orphanedNodes = nodes.filter(node => !positionedNodes.has(node.key));
            orphanedNodes.forEach((node, i) => {
                node.x = rootX + i * (cardWidth + horizontalGap);
                node.y = currentY;
                positionedNodes.add(node.key);
            });
            
            // Calculate total canvas size
            const canvasWidth = maxX + 40;
            const maxY = Math.max(...nodes.map(n => n.y));
            const canvasHeight = maxY + cardHeight + 40;
            
            // Set canvas size
            treeCanvas.style.width = `${canvasWidth}px`;
            treeCanvas.style.height = `${canvasHeight}px`;
            treeCanvas.style.position = 'relative';
            
            // Create connection lines SVG overlay
            const connectionsHtml = createConnectionLines(nodes, nodeMap, cardWidth, cardHeight);
            
            // Create variant cards
            const cardsHtml = nodes.map(node => createVariantCard(node, cardWidth, cardHeight)).join('');
            
            // Render the tree
            treeCanvas.innerHTML = connectionsHtml + cardsHtml;
            
            // Create minimap
            createMinimap(nodes, canvasWidth, canvasHeight, minimapSvg);
            
            // Add pan and zoom functionality
            initializeTreeNavigation(treeCanvas, minimap);
        }
        
        function createVariantCard(node, cardWidth, cardHeight) {
            const isRecent = isRecentlyCreated(node.created);
            const hybridBadge = node.is_hybrid ? '<span class="tree-badge hybrid">🧬 Hybrid</span>' : '';
            const newBadge = isRecent ? '<span class="tree-badge new">NEW</span>' : '';
            const generationBadge = `<span class="tree-badge generation">Gen ${node.generation}</span>`;
            
            // Add status badge based on variant state
            const statusBadge = getVariantStatusBadge(node);
            
            const jobInfo = (node.job_title || node.job_company) ? 
                `<div class="tree-card-job">🎯 ${node.job_title} ${node.job_company ? `@ ${node.job_company}` : ''}</div>` : '';
            
            const parentInfo = node.parents.length > 0 ? 
                `<div class="tree-card-parent">📁 Child of: ${node.parents.map(p => p.replace('.html', '')).join(', ')}</div>` : '';
            
            return `
                <div class="tree-card ${isRecent ? 'recent' : ''}" 
                     style="left: ${node.x}px; top: ${node.y}px; width: ${cardWidth}px; height: ${cardHeight}px;"
                     data-key="${node.key}">
                    <div class="tree-card-header">
                        <div class="tree-card-title">${node.name}</div>
                        <div class="tree-card-badges">
                            ${statusBadge}${newBadge}${hybridBadge}${generationBadge}
                        </div>
                    </div>
                    <div class="tree-card-content">
                        <div class="tree-card-desc">${node.description}</div>
                        ${jobInfo}
                        ${parentInfo}
                    </div>
                    <div class="tree-card-actions">
                        <button onclick="showPreview('http://localhost:8081/agent_workspace/variants/${node.key}', '${node.name}')" class="tree-btn">👁️</button>
                        <button onclick="quickBranchFromNode('${node.key}', '${node.name}')" class="tree-btn branch" title="Quick Branch">🌿</button>
                        <button onclick="exportToPDF('${node.key}')" class="tree-btn">📄</button>
                        ${node.parents.length > 0 ? `<button onclick="showComparison('${node.key}', '${node.parents[0]}')" class="tree-btn">🔍</button>` : ''}
                        <button onclick="deleteVariantFromTree('${node.key}', '${node.name}')" class="tree-btn delete" title="Delete Variant">🗑️</button>
                    </div>
                </div>
            `;
        }
        
        function createConnectionLines(nodes, nodeMap, cardWidth, cardHeight) {
            const lines = [];
            const cardCenterX = cardWidth / 2;
            const cardCenterY = cardHeight / 2;
            
            nodes.forEach(node => {
                if (node.parents && node.parents.length > 0) {
                    node.parents.forEach(parentKey => {
                        const parent = nodeMap[parentKey];
                        if (parent) {
                            const x1 = parent.x + cardCenterX;
                            const y1 = parent.y + cardHeight;
                            const x2 = node.x + cardCenterX;
                            const y2 = node.y;
                            
                            lines.push(`
                                <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                                      class="tree-connection ${node.is_hybrid ? 'hybrid' : ''}" 
                                      stroke-width="2" marker-end="url(#arrowhead)"/>
                            `);
                        }
                    });
                }
            });
            
            const maxX = Math.max(...nodes.map(n => n.x + cardWidth));
            const maxY = Math.max(...nodes.map(n => n.y + cardHeight));
            
            return `
                <svg class="tree-connections" style="position: absolute; top: 0; left: 0; width: ${maxX}px; height: ${maxY}px; pointer-events: none; z-index: 1;">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
                        </marker>
                    </defs>
                    ${lines.join('')}
                </svg>
            `;
        }
        
        function createMinimap(nodes, canvasWidth, canvasHeight, minimapSvg) {
            const scale = 0.25; // Larger minimap scale for better visibility
            const minimapWidth = canvasWidth * scale;
            const minimapHeight = canvasHeight * scale;
            
            // Set viewBox to fit the content with padding
            minimapSvg.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
            minimapSvg.style.width = '100%';
            minimapSvg.style.height = '100%';
            
            // Create connection lines for minimap
            const connectionLines = [];
            nodes.forEach(node => {
                if (node.parents && node.parents.length > 0) {
                    node.parents.forEach(parentKey => {
                        const parent = nodes.find(n => n.key === parentKey);
                        if (parent) {
                            connectionLines.push(`
                                <line x1="${parent.x + 140}" y1="${parent.y + 120}" 
                                      x2="${node.x + 140}" y2="${node.y}" 
                                      stroke="#cbd5e0" stroke-width="2"/>
                            `);
                        }
                    });
                }
            });
            
            // Create nodes with better visibility
            const minimapNodes = nodes.map(node => {
                const isRecent = isRecentlyCreated(node.created);
                let color = '#48bb78'; // Default variant color
                if (node.generation === 0) color = '#667eea'; // Base template
                if (node.is_hybrid) color = '#f56565'; // Hybrid
                if (isRecent) color = '#38a169'; // Recent variant (darker green)
                
                const strokeColor = isRecent ? '#2f855a' : 'white';
                const strokeWidth = isRecent ? '3' : '1';
                
                return `
                    <rect x="${node.x}" y="${node.y}" 
                          width="280" height="120" 
                          fill="${color}" 
                          stroke="${strokeColor}" 
                          stroke-width="${strokeWidth}"
                          rx="4" 
                          data-key="${node.key}"
                          style="cursor: pointer;">
                        <title>${node.name}</title>
                    </rect>
                    <text x="${node.x + 140}" y="${node.y + 65}" 
                          text-anchor="middle" 
                          fill="white" 
                          font-size="14" 
                          font-weight="bold"
                          pointer-events="none">
                        ${node.name.length > 20 ? node.name.substring(0, 17) + '...' : node.name}
                    </text>
                `;
            }).join('');
            
            minimapSvg.innerHTML = connectionLines.join('') + minimapNodes;
            
            // Add click handlers to minimap nodes
            minimapSvg.querySelectorAll('rect[data-key]').forEach(rect => {
                rect.addEventListener('click', (e) => {
                    const nodeKey = e.target.getAttribute('data-key');
                    focusOnNode(nodeKey);
                });
            });
            
            // Add click-to-navigate functionality for minimap area
            const minimapContent = document.querySelector('.minimap-content');
            minimapContent.addEventListener('click', (e) => {
                if (e.target.hasAttribute('data-key')) return; // Let node clicks handle themselves
                
                const minimapRect = minimapContent.getBoundingClientRect();
                const clickX = e.clientX - minimapRect.left;
                const clickY = e.clientY - minimapRect.top;
                
                // Convert minimap coordinates to main view scroll position
                const treeMain = document.getElementById('tree-main');
                const scrollRatioX = clickX / minimapRect.width;
                const scrollRatioY = clickY / minimapRect.height;
                
                const targetScrollX = scrollRatioX * (treeMain.scrollWidth - treeMain.clientWidth);
                const targetScrollY = scrollRatioY * (treeMain.scrollHeight - treeMain.clientHeight);
                
                treeMain.scrollTo({
                    left: Math.max(0, targetScrollX),
                    top: Math.max(0, targetScrollY),
                    behavior: 'smooth'
                });
            });
        }
        
        function initializeTreeNavigation(treeCanvas, minimap) {
            const treeMain = document.getElementById('tree-main');
            let isDragging = false;
            let lastX, lastY;
            
            // Enable scrolling
            treeMain.style.overflow = 'auto';
            
            // Pan functionality with drag
            treeMain.addEventListener('mousedown', (e) => {
                if (e.target.closest('.tree-card')) return; // Don't drag if clicking on cards
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                treeMain.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                
                treeMain.scrollLeft -= deltaX;
                treeMain.scrollTop -= deltaY;
                
                lastX = e.clientX;
                lastY = e.clientY;
                
                updateMinimapViewport();
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                treeMain.style.cursor = 'grab';
            });
            
            // Remove confusing zoom, just use scroll for navigation
            treeMain.addEventListener('scroll', updateMinimapViewport);
            
            updateMinimapViewport();
        }
        
        function focusOnNode(nodeKey) {
            const treeMain = document.getElementById('tree-main');
            const nodeCard = document.querySelector(`[data-key="${nodeKey}"]`);
            
            if (nodeCard) {
                const rect = nodeCard.getBoundingClientRect();
                const mainRect = treeMain.getBoundingClientRect();
                
                // Calculate position to center the node in the main view
                const scrollLeft = nodeCard.offsetLeft - treeMain.clientWidth / 2 + 140; // 140 = card width / 2
                const scrollTop = nodeCard.offsetTop - treeMain.clientHeight / 2 + 60; // 60 = card height / 2
                
                treeMain.scrollTo({
                    left: Math.max(0, scrollLeft),
                    top: Math.max(0, scrollTop),
                    behavior: 'smooth'
                });
                
                // Highlight the focused node briefly
                nodeCard.style.boxShadow = '0 0 20px rgba(66, 133, 244, 0.6)';
                setTimeout(() => {
                    nodeCard.style.boxShadow = '';
                }, 2000);
            }
        }
        
        function focusOnRecent() {
            const treeMain = document.getElementById('tree-main');
            const recentCard = document.querySelector('.tree-card.recent');
            
            if (recentCard) {
                const nodeKey = recentCard.getAttribute('data-key');
                focusOnNode(nodeKey);
            } else {
                // If no recent cards, focus on the first card
                const firstCard = document.querySelector('.tree-card');
                if (firstCard) {
                    const nodeKey = firstCard.getAttribute('data-key');
                    focusOnNode(nodeKey);
                }
            }
        }
        
        function resetTreeView() {
            const treeMain = document.getElementById('tree-main');
            treeMain.scrollTo({
                left: 0,
                top: 0,
                behavior: 'smooth'
            });
        }
        
        function updateMinimapViewport() {
            const treeMain = document.getElementById('tree-main');
            const viewport = document.getElementById('minimap-viewport');
            const minimapContent = document.querySelector('.minimap-content');
            
            if (!minimapContent) return;
            
            // Get the actual minimap content area (excluding header)
            const minimapRect = minimapContent.getBoundingClientRect();
            const minimapWidth = minimapRect.width - 4; // Account for padding/borders
            const minimapHeight = minimapRect.height - 4;
            
            // Calculate more precise scroll ratios
            const maxScrollX = Math.max(0, treeMain.scrollWidth - treeMain.clientWidth);
            const maxScrollY = Math.max(0, treeMain.scrollHeight - treeMain.clientHeight);
            
            const scrollRatioX = maxScrollX > 0 ? treeMain.scrollLeft / maxScrollX : 0;
            const scrollRatioY = maxScrollY > 0 ? treeMain.scrollTop / maxScrollY : 0;
            
            // Calculate viewport size more accurately - show only the visible portion
            const viewportWidthRatio = Math.min(0.95, treeMain.clientWidth / treeMain.scrollWidth);
            const viewportHeightRatio = Math.min(0.95, treeMain.clientHeight / treeMain.scrollHeight);
            
            // Calculate actual dimensions with reduced dead space
            const viewportWidth = Math.max(20, minimapWidth * viewportWidthRatio);
            const viewportHeight = Math.max(20, minimapHeight * viewportHeightRatio);
            
            // Position with reduced margins
            const availableX = minimapWidth - viewportWidth;
            const availableY = minimapHeight - viewportHeight;
            
            const viewportX = scrollRatioX * availableX;
            const viewportY = scrollRatioY * availableY;
            
            viewport.style.left = `${viewportX + 2}px`;
            viewport.style.top = `${viewportY + 2}px`;
            viewport.style.width = `${viewportWidth}px`;
            viewport.style.height = `${viewportHeight}px`;
        }
        
        function isRecentlyCreated(created) {
            if (!created) return false;
            const createdTime = new Date(created).getTime();
            const now = Date.now();
            return (now - createdTime) < (5 * 60 * 1000); // 5 minutes
        }
        
        // Additional helper functions
        function loadJobToEditor(filename) {
            const job = availableJobs.find(j => j.filename === filename);
            if (job) {
                document.getElementById('new-job-name').value = `${job.title} - ${job.company}`;
                
                // Load full content
                fetch(`/agent_workspace/job_descriptions/${filename}`)
                    .then(response => response.text())
                    .then(content => {
                        document.getElementById('new-job-content').value = content;
                        showTab('manage-jobs');
                    })
                    .catch(error => {
                        document.getElementById('new-job-content').value = job.preview.replace('...', '\\n\\n[Full content - please edit as needed]');
                        showTab('manage-jobs');
                    });
            }
        }
        
        async function deleteJob(filename) {
            if (confirm('Are you sure you want to delete this job description?')) {
                try {
                    const response = await fetch('/api/delete-job-description', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ filename: filename })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        showNotification(result.message, 'success');
                        // Refresh the job descriptions list
                        await loadJobDescriptions();
                    } else {
                        showNotification('Failed to delete job description', 'error');
                    }
                } catch (error) {
                    showNotification('Error deleting job description', 'error');
                }
            }
        }
        
        // Search functionality
        function clearSearch() {
            document.getElementById('search-input').value = '';
            updateDashboard();
        }
        
        // Job Description State Management
        let originalJobContent = '';
        let isExistingJob = false;
        let hasUserContent = false; // Track if user has pasted/typed content
        let hasLinkedInContent = false; // Track if LinkedIn has fetched content
        let currentJobName = ''; // Track current job for scroll minimization
        let lastSavedJobName = ''; // Track last saved job name
        
        function expandJobDescription(hideLinkedIn = false, showSave = true, minimizeLinkedIn = false) {
            const textarea = document.getElementById('job-description');
            const container = document.getElementById('job-input-container');
            const linkedinSection = document.getElementById('linkedin-section');
            const actions = document.getElementById('job-actions');
            
            // Switch to large mode
            textarea.classList.remove('small');
            textarea.classList.add('large');
            container.classList.remove('small-mode');
            container.classList.add('large-mode');
            linkedinSection.classList.add('large-mode');
            
            // Handle LinkedIn section visibility
            linkedinSection.classList.remove('hidden', 'minimal');
            if (hideLinkedIn) {
                linkedinSection.classList.add('hidden');
            } else if (minimizeLinkedIn) {
                linkedinSection.classList.add('minimal');
            }
            
            // Show save button only if needed
            if (showSave) {
                actions.classList.add('visible');
            } else {
                actions.classList.remove('visible');
            }
        }
        
        function collapseJobDescription() {
            const textarea = document.getElementById('job-description');
            const container = document.getElementById('job-input-container');
            const linkedinSection = document.getElementById('linkedin-section');
            const actions = document.getElementById('job-actions');
            
            // Switch to small mode
            textarea.classList.remove('large');
            textarea.classList.add('small');
            container.classList.remove('large-mode');
            container.classList.add('small-mode');
            linkedinSection.classList.remove('large-mode', 'hidden', 'minimal');
            actions.classList.remove('visible');
            
            // Reset state
            hasUserContent = false;
            hasLinkedInContent = false;
        }
        
        function checkIfContentChanged() {
            const textarea = document.getElementById('job-description');
            const currentContent = textarea.value.trim();
            const actions = document.getElementById('job-actions');
            
            // Show save button if:
            // 1. New content (was empty, now has content)
            // 2. Existing job content was modified
            const hasNewContent = !isExistingJob && currentContent.length > 10;
            const hasModifiedContent = isExistingJob && currentContent !== originalJobContent;
            
            if (hasNewContent || hasModifiedContent) {
                actions.classList.add('visible');
            } else if (isExistingJob && currentContent === originalJobContent) {
                actions.classList.remove('visible');
            }
        }
        
        function checkJobDescriptionContent() {
            const textarea = document.getElementById('job-description');
            const content = textarea.value.trim();
            
            if (content.length > 10) {
                // Determine LinkedIn visibility based on content source
                const hideLinkedIn = isExistingJob;
                const minimizeLinkedIn = (hasUserContent && !isExistingJob) || hasLinkedInContent;
                
                expandJobDescription(hideLinkedIn, false, minimizeLinkedIn);
                checkIfContentChanged();
            } else {
                collapseJobDescription();
                isExistingJob = false;
                originalJobContent = '';
                hasUserContent = false;
                hasLinkedInContent = false;
            }
        }
        
        // Scroll-based minimization
        function updateJobStepTitle() {
            const step = document.querySelector('.workflow-step');
            const h3 = step.querySelector('h3');
            
            if (currentJobName) {
                h3.setAttribute('data-current-job', currentJobName);
            } else {
                h3.removeAttribute('data-current-job');
            }
        }
        
        function shouldMinimizeOnScroll() {
            // Don't minimize if:
            // 1. Content was pasted/typed but not saved
            // 2. LinkedIn content was fetched but not saved
            const textarea = document.getElementById('job-description');
            const content = textarea ? textarea.value.trim() : '';
            
            console.log('shouldMinimize check:', {
                contentLength: content.length,
                isExistingJob,
                hasUserContent,
                hasLinkedInContent,
                lastSavedJobName,
                currentJobName
            });
            
            if (content.length > 10) {
                // Has content - check if it's saved
                if (hasUserContent && !lastSavedJobName) {
                    console.log('Blocking minimize: pasted but not saved');
                    return false; // Pasted/typed but not saved
                }
                if (!isExistingJob && !hasUserContent && hasLinkedInContent && !lastSavedJobName) {
                    console.log('Blocking minimize: LinkedIn but not saved');
                    return false; // LinkedIn fetched but not saved
                }
            }
            
            console.log('Allowing minimize');
            return true; // Safe to minimize
        }
        
        function handleScroll() {
            // Get all workflow steps and target the first one
            const allSteps = document.querySelectorAll('.workflow-step');
            const step1 = allSteps[0];
            
            if (!step1) {
                console.log('Step1 not found among', allSteps.length, 'steps');
                return;
            }
            
            const step1Rect = step1.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const windowHeight = window.innerHeight;
            
            // Check if step1 is scrolled past (its bottom is above the top 20% of viewport)
            const threshold = windowHeight * 0.2;
            const shouldMinimize = step1Rect.bottom < threshold;
            
            console.log('Enhanced Scroll Debug:', {
                stepIndex: Array.from(allSteps).indexOf(step1),
                stepId: step1.id,
                stepClass: step1.className,
                step1Rect: {
                    top: Math.round(step1Rect.top),
                    bottom: Math.round(step1Rect.bottom),
                    height: Math.round(step1Rect.height)
                },
                scrollTop: Math.round(scrollTop),
                windowHeight: Math.round(windowHeight),
                threshold: Math.round(threshold),
                shouldMinimize: shouldMinimize,
                canMinimize: shouldMinimizeOnScroll(),
                currentlyMinimized: step1.classList.contains('minimized')
            });
            
            if (shouldMinimize && shouldMinimizeOnScroll()) {
                if (!step1.classList.contains('minimized')) {
                    console.log('✅ Adding minimized class to step1');
                    step1.classList.add('minimized');
                }
            } else {
                if (step1.classList.contains('minimized')) {
                    console.log('❌ Removing minimized class from step1');
                    step1.classList.remove('minimized');
                }
            }
        }
        
        // Preview Overlay Functions
        let currentPreviewFilename = null;
        
        function showPreview(url, title) {
            const overlay = document.getElementById('preview-overlay');
            const iframe = document.getElementById('preview-iframe');
            const titleElement = document.getElementById('preview-title');
            const downloadBtn = document.getElementById('preview-download');
            
            titleElement.textContent = title || 'Resume Preview';
            iframe.src = url;
            overlay.classList.add('active');
            
            // Extract filename from URL for PDF download
            const urlParts = url.split('/');
            const filename = urlParts[urlParts.length - 1];
            currentPreviewFilename = filename.replace('.html', '');
            
            // Enable download button
            downloadBtn.disabled = false;
            
            // Prevent body scroll when overlay is open
            document.body.style.overflow = 'hidden';
        }
        
        function closePreview() {
            const overlay = document.getElementById('preview-overlay');
            const iframe = document.getElementById('preview-iframe');
            const downloadBtn = document.getElementById('preview-download');
            
            overlay.classList.remove('active');
            iframe.src = '';
            currentPreviewFilename = null;
            downloadBtn.disabled = true;
            
            // Restore body scroll
            document.body.style.overflow = '';
        }
        
        async function downloadPreviewedPDF() {
            if (!currentPreviewFilename) {
                showNotification('No file selected for download', 'error');
                return;
            }
            
            try {
                const downloadBtn = document.getElementById('preview-download');
                downloadBtn.disabled = true;
                downloadBtn.textContent = '🔄 Converting...';
                
                showNotification('Converting to PDF...', 'info');
                
                // First, trigger PDF generation on the server
                const convertResponse = await fetch('/api/convert-to-pdf', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        variant_name: currentPreviewFilename
                    })
                });
                
                const convertResult = await convertResponse.json();
                
                if (convertResult.success) {
                    // PDF was generated successfully, now download it
                    const pdfFilename = currentPreviewFilename.replace('.html', '') + '.pdf';
                    const downloadUrl = `/agent_workspace/output/${pdfFilename}`;
                    
                    // Create download link
                    const link = document.createElement('a');
                    link.href = downloadUrl;
                    link.download = pdfFilename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    showNotification('PDF downloaded successfully!', 'success');
                } else {
                    throw new Error(convertResult.message || 'PDF conversion failed');
                }
            } catch (error) {
                console.error('PDF conversion error:', error);
                showNotification('Error converting to PDF: ' + error.message, 'error');
            } finally {
                // Re-enable the download button
                const downloadBtn = document.getElementById('preview-download');
                downloadBtn.disabled = false;
                downloadBtn.textContent = '📄 Download PDF';
            }
        }
        
        // Batch Testing Functions
        function showBatchTesting() {
            const batchStep = document.getElementById('batch-testing-step');
            batchStep.style.display = 'block';
            batchStep.scrollIntoView({ behavior: 'smooth' });
        }
        
        function hideBatchTesting() {
            const batchStep = document.getElementById('batch-testing-step');
            batchStep.style.display = 'none';
            
            // Reset forms
            document.querySelectorAll('.batch-option input[type="checkbox"]').forEach(cb => {
                cb.checked = cb.value === 'tech-focused' || cb.value === 'leadership-focused';
            });
            document.getElementById('custom-directives').value = '';
            
            // Hide progress and results
            document.getElementById('batch-progress').style.display = 'none';
            document.getElementById('batch-results').style.display = 'none';
        }
        
        async function launchBatchTesting() {
            const jobDescription = document.getElementById('job-description').value;
            if (!jobDescription.trim()) {
                showNotification('Please provide a job description before batch testing', 'error');
                return;
            }
            
            if (selectedParents.length === 0) {
                showNotification('Please select at least one parent template', 'error');
                return;
            }
            
            // Gather selected strategies
            const strategies = [];
            document.querySelectorAll('.batch-option input[type="checkbox"]:checked').forEach(cb => {
                strategies.push(cb.value);
            });
            
            // Parse custom directives
            const customDirectives = document.getElementById('custom-directives').value
                .split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            if (strategies.length === 0 && customDirectives.length === 0) {
                showNotification('Please select at least one strategy or add custom directives', 'error');
                return;
            }
            
            // Show progress section
            const progressSection = document.getElementById('batch-progress');
            const resultsSection = document.getElementById('batch-results');
            progressSection.style.display = 'block';
            resultsSection.style.display = 'none';
            
            try {
                await executeBatchTesting(strategies, customDirectives, jobDescription);
            } catch (error) {
                showNotification('Batch testing failed: ' + error.message, 'error');
                console.error('Batch testing error:', error);
            }
        }
        
        async function executeBatchTesting(strategies, customDirectives, jobDescription) {
            const totalTasks = strategies.length + customDirectives.length;
            const agentStatusList = document.getElementById('batch-agent-status');
            const progressFill = document.getElementById('batch-progress-fill');
            const progressText = document.getElementById('batch-progress-text');
            
            let completedTasks = 0;
            const results = [];
            
            // Initialize agent status display
            agentStatusList.innerHTML = '';
            
            const updateProgress = (completed, total, currentTask = '') => {
                const percentage = (completed / total) * 100;
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = currentTask || `${completed}/${total} agents completed`;
            };
            
            updateProgress(0, totalTasks, 'Initializing batch testing...');
            
            // Create agent status items
            const allTasks = [...strategies, ...customDirectives.map(d => `custom-${Date.now()}`)];
            allTasks.forEach((task, index) => {
                const statusItem = createAgentStatusItem(task, index + 1);
                agentStatusList.appendChild(statusItem);
            });
            
            // Execute strategy-based variants
            for (let i = 0; i < strategies.length; i++) {
                const strategy = strategies[i];
                const agentId = `agent-${i + 1}`;
                
                updateAgentStatus(agentId, '🔄', 'Processing...');
                updateProgress(completedTasks, totalTasks, `Agent ${i + 1}: Creating ${strategy} variant...`);
                
                try {
                    const result = await createStrategyVariant(strategy, jobDescription, selectedParents[0]);
                    results.push({
                        strategy: strategy,
                        result: result,
                        type: 'strategy'
                    });
                    updateAgentStatus(agentId, '✅', 'Completed');
                } catch (error) {
                    console.error(`Strategy ${strategy} failed:`, error);
                    updateAgentStatus(agentId, '❌', 'Failed');
                    results.push({
                        strategy: strategy,
                        error: error.message,
                        type: 'strategy'
                    });
                }
                
                completedTasks++;
                updateProgress(completedTasks, totalTasks);
            }
            
            // Execute custom directive variants
            for (let i = 0; i < customDirectives.length; i++) {
                const directive = customDirectives[i];
                const agentId = `agent-${strategies.length + i + 1}`;
                
                updateAgentStatus(agentId, '🔄', 'Processing...');
                updateProgress(completedTasks, totalTasks, `Agent ${strategies.length + i + 1}: Custom directive...`);
                
                try {
                    const result = await createCustomVariant(directive, jobDescription, selectedParents[0]);
                    results.push({
                        directive: directive,
                        result: result,
                        type: 'custom'
                    });
                    updateAgentStatus(agentId, '✅', 'Completed');
                } catch (error) {
                    console.error(`Custom directive failed:`, error);
                    updateAgentStatus(agentId, '❌', 'Failed');
                    results.push({
                        directive: directive,
                        error: error.message,
                        type: 'custom'
                    });
                }
                
                completedTasks++;
                updateProgress(completedTasks, totalTasks);
            }
            
            updateProgress(totalTasks, totalTasks, 'Batch testing completed!');
            
            // Show results
            setTimeout(() => {
                displayBatchResults(results);
                
                // Auto-generate PDFs if enabled
                if (document.getElementById('auto-pdf').checked) {
                    generateBatchPDFs(results);
                }
                
                // Refresh dashboard
                loadInitialData();
            }, 1000);
        }
        
        function createAgentStatusItem(task, agentNumber) {
            const item = document.createElement('div');
            item.className = 'agent-status-item';
            item.id = `agent-${agentNumber}`;
            
            const strategyName = task.startsWith('custom-') ? 'Custom Directive' : task.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            item.innerHTML = `
                <div class="agent-status-icon">⏳</div>
                <div class="agent-status-text">
                    <div class="agent-status-name">Agent ${agentNumber}: ${strategyName}</div>
                    <div class="agent-status-progress">Waiting...</div>
                </div>
            `;
            
            return item;
        }
        
        function updateAgentStatus(agentId, icon, status) {
            const agent = document.getElementById(agentId);
            if (agent) {
                agent.querySelector('.agent-status-icon').textContent = icon;
                agent.querySelector('.agent-status-progress').textContent = status;
            }
        }
        
        async function createStrategyVariant(strategy, jobDescription, parentTemplate) {
            // Use existing API with batch mode
            const response = await fetch('/api/create-variant', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    parent_template: parentTemplate,
                    job_description: jobDescription,
                    focus_type: strategy,
                    batch_mode: true,
                    strategy_focus: getStrategyDescription(strategy)
                })
            });
            
            return await response.json();
        }
        
        async function createCustomVariant(directive, jobDescription, parentTemplate) {
            // Use existing API with custom directive
            const response = await fetch('/api/create-variant', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    parent_template: parentTemplate,
                    job_description: jobDescription,
                    focus_type: 'custom',
                    custom_directive: directive,
                    batch_mode: true
                })
            });
            
            return await response.json();
        }
        
        function getStrategyDescription(strategy) {
            const descriptions = {
                // Batch strategies
                'tech-focused': 'Emphasize technical skills, architecture experience, and engineering depth',
                'leadership-focused': 'Highlight team management, strategic impact, and leadership experience',
                'startup-optimized': 'Focus on versatility, fast-paced environment adaptation, and growth orientation',
                'enterprise-optimized': 'Emphasize process orientation, compliance experience, and scale management',
                'keyword-maximized': 'Maximize ATS keyword matching with job description requirements',
                'creative-format': 'Alternative layout design while maintaining ATS compatibility',
                
                // Single generation agent commands
                'optimize': 'Standard optimization for job requirements and ATS compatibility',
                'enhance_keywords': 'Enhance keyword density and relevance for ATS systems',
                'improve_ats': 'Optimize formatting and structure for ATS parsing',
                'customize_role': 'Customize content specifically for the target role',
                'strengthen_metrics': 'Add and strengthen quantifiable achievements and metrics',
                'format_cleanup': 'Clean up formatting while maintaining ATS compatibility',
                'professional_tone': 'Enhance professional tone and language throughout',
                'technical_focus': 'Emphasize technical skills and engineering experience',
                'leadership_emphasis': 'Highlight leadership and management capabilities',
                'custom': 'Apply custom optimization based on provided instructions',
                
                // Focus types
                'tech': 'Technical skills and architecture focus',
                'leadership': 'Leadership and management focus',
                'startup': 'Startup environment optimization',
                'enterprise': 'Enterprise environment optimization',
                'remote': 'Remote work optimization',
                'local': 'Local position optimization'
            };
            return descriptions[strategy] || strategy;
        }
        
        function displayBatchResults(results) {
            const resultsSection = document.getElementById('batch-results');
            const resultsGrid = document.getElementById('batch-results-grid');
            
            resultsGrid.innerHTML = '';
            
            results.forEach((item, index) => {
                const card = createBatchResultCard(item, index + 1);
                resultsGrid.appendChild(card);
            });
            
            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        }
        
        function createBatchResultCard(item, index) {
            const card = document.createElement('div');
            card.className = 'batch-result-card';
            
            const title = item.strategy ? item.strategy.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()) : `Custom ${index}`;
            const strategy = item.strategy || 'Custom Directive';
            const isSuccess = item.result && item.result.success;
            const description = item.directive || getStrategyDescription(item.strategy) || 'Custom optimization directive';
            
            card.innerHTML = `
                <div class="batch-result-header">
                    <div class="batch-result-title">${title}</div>
                    <div class="batch-result-strategy">${strategy}</div>
                </div>
                <div class="batch-result-preview">${description}</div>
                <div class="batch-result-actions">
                    ${isSuccess ? 
                        `<button onclick="showPreview('${item.result.preview_url}', '${title}')" class="btn-compact preview">👁️ Preview</button>
                         <button onclick="exportToPDF('${item.result.variant_name}')" class="btn-compact export">📄 PDF</button>` :
                        `<button disabled class="btn-compact">❌ Failed</button>`
                    }
                </div>
            `;
            
            return card;
        }
        
        function showBatchComparison() {
            showNotification('Batch comparison feature coming soon!', 'info');
            // TODO: Implement side-by-side comparison view
        }
        
        function exportBatchResults() {
            showNotification('Batch export feature coming soon!', 'info');
            // TODO: Implement batch PDF export
        }
        
        async function generateBatchPDFs(results) {
            const successfulResults = results.filter(r => r.result && r.result.success);
            
            for (const result of successfulResults) {
                try {
                    await exportToPDF(result.result.variant_name);
                } catch (error) {
                    console.error('PDF generation failed for', result.result.variant_name, error);
                }
            }
            
            showNotification(`Generated PDFs for ${successfulResults.length} variants`, 'success');
        }
        
        // Quality Control and Prompt Refinement Functions
        let currentQualityVariant = null;
        let qualityFeedbackData = JSON.parse(localStorage.getItem('qualityFeedback') || '{}');
        let promptInstructions = localStorage.getItem('promptInstructions') || 'Create an ATS-optimized resume that maintains professional formatting while maximizing keyword relevance. Focus on quantifiable achievements and clear, concise descriptions. Ensure single-page layout with proper spacing and hierarchy.';
        
        function showQualityControls(filename, name) {
            currentQualityVariant = { filename, name };
            const modal = document.getElementById('quality-modal');
            const title = document.getElementById('quality-title');
            
            title.textContent = `Quality Assessment: ${name}`;
            
            // Load existing rating if available
            const existingFeedback = qualityFeedbackData[filename];
            if (existingFeedback) {
                setStarRating(existingFeedback.rating || 0);
                
                // Set checkboxes
                const checkboxes = document.querySelectorAll('.feedback-checkboxes input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = existingFeedback.issues && existingFeedback.issues.includes(cb.value);
                });
                
                // Set feedback text
                document.getElementById('quality-feedback').value = existingFeedback.feedback || '';
            } else {
                resetQualityForm();
            }
            
            // Populate comparison templates
            populateComparisonTemplates();
            
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        function closeQualityModal() {
            const modal = document.getElementById('quality-modal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
            currentQualityVariant = null;
        }
        
        function resetQualityForm() {
            setStarRating(0);
            document.querySelectorAll('.feedback-checkboxes input[type="checkbox"]').forEach(cb => cb.checked = false);
            document.getElementById('quality-feedback').value = '';
            document.getElementById('quality-analysis').innerHTML = '';
        }
        
        function setStarRating(rating) {
            const stars = document.querySelectorAll('.star');
            stars.forEach((star, index) => {
                star.classList.toggle('active', index < rating);
            });
        }
        
        // Star rating click handler
        document.addEventListener('DOMContentLoaded', function() {
            const stars = document.querySelectorAll('.star');
            stars.forEach(star => {
                star.addEventListener('click', function() {
                    const rating = parseInt(this.dataset.rating);
                    setStarRating(rating);
                });
            });
        });
        
        function populateComparisonTemplates() {
            const select = document.getElementById('compare-template');
            select.innerHTML = '<option value="">Compare with existing high-quality variant...</option>';
            
            // Add high-rated variants (4+ stars)
            Object.keys(qualityFeedbackData).forEach(filename => {
                const feedback = qualityFeedbackData[filename];
                if (feedback.rating >= 4) {
                    const variant = availableVariants.find(v => v.filename === filename);
                    if (variant) {
                        select.innerHTML += `<option value="${filename}">${variant.name} (${feedback.rating}⭐)</option>`;
                    }
                }
            });
        }
        
        async function submitQualityFeedback() {
            if (!currentQualityVariant) return;
            
            const rating = document.querySelectorAll('.star.active').length;
            const issues = Array.from(document.querySelectorAll('.feedback-checkboxes input[type="checkbox"]:checked'))
                .map(cb => cb.value);
            const feedback = document.getElementById('quality-feedback').value;
            
            const feedbackData = {
                rating,
                issues,
                feedback,
                timestamp: new Date().toISOString(),
                filename: currentQualityVariant.filename
            };
            
            // Store feedback locally
            qualityFeedbackData[currentQualityVariant.filename] = feedbackData;
            localStorage.setItem('qualityFeedback', JSON.stringify(qualityFeedbackData));
            
            // Send to server for analysis
            try {
                await fetch('/api/save-quality-feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(feedbackData)
                });
            } catch (error) {
                console.log('Quality feedback saved locally (server unavailable)');
            }
            
            showNotification(`Quality feedback saved for ${currentQualityVariant.name}`, 'success');
            closeQualityModal();
            updateDashboard(); // Refresh to show quality indicators
        }
        
        async function analyzeQualityGap() {
            const compareWith = document.getElementById('compare-template').value;
            if (!compareWith || !currentQualityVariant) {
                showNotification('Please select a template to compare with', 'error');
                return;
            }
            
            const analysisDiv = document.getElementById('quality-analysis');
            analysisDiv.innerHTML = '<div>🔍 Analyzing differences...</div>';
            
            try {
                const response = await fetch('/api/analyze-quality-gap', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        current_variant: currentQualityVariant.filename,
                        comparison_variant: compareWith
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    analysisDiv.innerHTML = `
                        <h5>📊 Quality Analysis Results</h5>
                        <p><strong>Key Differences:</strong></p>
                        <ul>
                            ${result.differences.map(diff => `<li>${diff}</li>`).join('')}
                        </ul>
                        <p><strong>Recommendations:</strong></p>
                        <ul>
                            ${result.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                        </ul>
                    `;
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                analysisDiv.innerHTML = `
                    <div>❌ Analysis failed: ${error.message}</div>
                    <p>Manual comparison suggested: Review formatting, content density, and keyword usage between variants.</p>
                `;
            }
        }
        
        function deleteVariant(filename, name) {
            if (confirm(`Are you sure you want to delete "${name}"? This action cannot be undone.`)) {
                currentQualityVariant = { filename, name };
                deleteCurrentVariant();
            }
        }
        
        async function deleteCurrentVariant() {
            if (!currentQualityVariant) return;
            
            try {
                const response = await fetch('/api/delete-variant', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: currentQualityVariant.filename
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Remove from quality feedback data
                    delete qualityFeedbackData[currentQualityVariant.filename];
                    localStorage.setItem('qualityFeedback', JSON.stringify(qualityFeedbackData));
                    
                    showNotification(`Deleted ${currentQualityVariant.name}`, 'success');
                    closeQualityModal();
                    loadInitialData(); // Refresh dashboard
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                showNotification(`Error deleting variant: ${error.message}`, 'error');
            }
        }
        
        function refinePromptFromFeedback() {
            closeQualityModal();
            showPromptRefinement();
        }
        
        function showPromptRefinement() {
            const modal = document.getElementById('prompt-modal');
            
            // Load current instructions
            document.getElementById('base-instructions').value = promptInstructions;
            
            // Analyze feedback patterns
            analyzeQualityPatterns();
            
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        function closePromptModal() {
            const modal = document.getElementById('prompt-modal');
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        function analyzeQualityPatterns() {
            const exampleAnalysis = document.getElementById('example-analysis');
            const formattingIssues = document.getElementById('formatting-issues');
            const contentIssues = document.getElementById('content-issues');
            const atsIssues = document.getElementById('ats-issues');
            
            // Analyze quality feedback patterns
            const allFeedback = Object.values(qualityFeedbackData);
            const lowRatedVariants = allFeedback.filter(f => f.rating <= 2);
            const highRatedVariants = allFeedback.filter(f => f.rating >= 4);
            
            // Common issues analysis
            const commonIssues = {
                formatting: 0,
                content: 0,
                keywords: 0,
                length: 0,
                ats: 0,
                focus: 0
            };
            
            lowRatedVariants.forEach(feedback => {
                if (feedback.issues) {
                    feedback.issues.forEach(issue => {
                        if (commonIssues.hasOwnProperty(issue)) {
                            commonIssues[issue]++;
                        }
                    });
                }
            });
            
            // Update issue patterns
            formattingIssues.textContent = commonIssues.formatting > 0 ? 
                `Avoid poor spacing, inconsistent fonts, or overflow (${commonIssues.formatting} issues)` : 
                'No major formatting issues detected';
                
            contentIssues.textContent = commonIssues.content > 0 ? 
                `Improve skills matching and achievement quantification (${commonIssues.content} issues)` : 
                'Content quality generally good';
                
            atsIssues.textContent = commonIssues.ats > 0 ? 
                `Ensure proper section headers and keyword placement (${commonIssues.ats} issues)` : 
                'ATS compatibility maintained';
            
            // High-quality variant analysis
            if (highRatedVariants.length > 0) {
                exampleAnalysis.innerHTML = `
                    <h5>🌟 High-Quality Variant Patterns (${highRatedVariants.length} examples)</h5>
                    <p><strong>Common Success Factors:</strong></p>
                    <ul>
                        <li>Clean, consistent formatting with proper spacing</li>
                        <li>Strong action verbs and quantified achievements</li>
                        <li>Relevant keyword integration without stuffing</li>
                        <li>Single-page layout with optimal content density</li>
                        <li>Clear section hierarchy and ATS-friendly structure</li>
                    </ul>
                `;
            } else {
                exampleAnalysis.innerHTML = `
                    <p>No high-rated variants yet. Create and rate some variants to build quality patterns.</p>
                `;
            }
            
            // Generate refined instructions
            generateRefinedInstructions(commonIssues, highRatedVariants.length);
        }
        
        function generateRefinedInstructions(commonIssues, highQualityCount) {
            const refinedTextarea = document.getElementById('refined-instructions');
            
            let refinedInstructions = promptInstructions;
            
            // Add specific improvements based on common issues
            if (commonIssues.formatting > 0) {
                refinedInstructions += '\n\nFORMATTING REQUIREMENTS:\n- Use consistent font sizes and spacing\n- Ensure proper margins and section separation\n- Maintain professional visual hierarchy\n- Test for single-page compliance';
            }
            
            if (commonIssues.content > 0) {
                refinedInstructions += '\n\nCONTENT OPTIMIZATION:\n- Start each bullet with strong action verbs\n- Include specific metrics and achievements\n- Match skills closely to job requirements\n- Focus on relevant experience and impact';
            }
            
            if (commonIssues.ats > 0) {
                refinedInstructions += '\n\nATS COMPLIANCE:\n- Use standard section headers (Experience, Education, Skills)\n- Avoid tables, graphics, or complex formatting\n- Include relevant keywords naturally in content\n- Maintain readable plain-text structure';
            }
            
            if (highQualityCount > 0) {
                refinedInstructions += `\n\nQUALITY BENCHMARKS:\nReference the formatting and content patterns from high-rated variants. Maintain the same level of professionalism and keyword optimization found in successful examples.`;
            }
            
            refinedTextarea.value = refinedInstructions;
        }
        
        function saveRefinedInstructions() {
            const refinedText = document.getElementById('refined-instructions').value;
            promptInstructions = refinedText;
            localStorage.setItem('promptInstructions', refinedText);
            
            showNotification('Refined instructions saved successfully', 'success');
            closePromptModal();
        }
        
        async function regenerateVariant() {
            if (!currentQualityVariant) return;
            
            closeQualityModal();
            
            // Use the current job description and refined instructions
            const jobDescription = document.getElementById('job-description').value;
            const parentTemplate = selectedParents.length > 0 ? selectedParents[0] : 'base_resume.html';
            
            try {
                showNotification('Regenerating with improved instructions...', 'info');
                
                const response = await fetch('/api/create-variant', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        parent_template: parentTemplate,
                        job_description: jobDescription,
                        focus_type: 'improved',
                        improvement_feedback: qualityFeedbackData[currentQualityVariant.filename],
                        refined_instructions: promptInstructions,
                        replace_variant: currentQualityVariant.filename
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showNotification('Variant regenerated with improvements', 'success');
                    loadInitialData();
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                showNotification(`Regeneration failed: ${error.message}`, 'error');
            }
        }
        
        function testRefinedPrompt() {
            showNotification('Test functionality will use a sample job description to validate the refined prompt', 'info');
            // TODO: Implement test generation with sample job
        }
        
        function resetToDefaults() {
            const defaultInstructions = 'Create an ATS-optimized resume that maintains professional formatting while maximizing keyword relevance. Focus on quantifiable achievements and clear, concise descriptions. Ensure single-page layout with proper spacing and hierarchy.';
            document.getElementById('refined-instructions').value = defaultInstructions;
        }
        
        // Close preview with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closePreview();
            }
        });
        
        // Close preview when clicking outside the container
        document.getElementById('preview-overlay').addEventListener('click', function(e) {
            if (e.target === this) {
                closePreview();
            }
        });
        
        // Add search event listener and job description monitoring
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    updateDashboard(this.value);
                });
            }
            
            // Monitor job description changes
            const jobDescription = document.getElementById('job-description');
            if (jobDescription) {
                jobDescription.addEventListener('input', function() {
                    // If user is typing and this isn't an existing job, mark as user content
                    if (!isExistingJob && this.value.trim().length > 10) {
                        hasUserContent = true;
                    }
                    checkJobDescriptionContent();
                    checkIfContentChanged();
                });
                jobDescription.addEventListener('paste', function() {
                    // For pasted content, reset to new job state
                    isExistingJob = false;
                    originalJobContent = '';
                    hasUserContent = true; // Mark that user has provided content
                    hasLinkedInContent = false; // Reset LinkedIn flag since this is now user content
                    // Slight delay to allow paste content to be processed
                    setTimeout(() => {
                        checkJobDescriptionContent();
                        checkIfContentChanged();
                    }, 100);
                });
            }
            
            // Add scroll listener with throttling
            let scrollTimeout;
            window.addEventListener('scroll', function() {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(handleScroll, 50); // Throttle to 50ms
            });
            
            // Test scroll listener
            console.log('Scroll listener added');
            
            // Initial check
            setTimeout(handleScroll, 1000);
        });

        // Quick Branch and Tree Management Functions
        async function quickBranchFromNode(nodeKey, nodeName) {
            try {
                // Show quick branch modal
                const result = await showQuickBranchModal(nodeKey, nodeName);
                if (!result) return;
                
                const { jobTitle, jobCompany, focusType, agentCommand } = result;
                
                showNotification('Creating branch variant...', 'info');
                console.log('Quick branch data:', { nodeKey, jobTitle, jobCompany, focusType, agentCommand });
                
                // Build job description from the form inputs
                let jobDescription = '';
                if (jobTitle && jobCompany) {
                    jobDescription = `Job Title: ${jobTitle}\nCompany: ${jobCompany}\n\n`;
                }
                if (agentCommand) {
                    jobDescription += agentCommand;
                } else {
                    jobDescription += `Optimize this resume for the ${jobTitle || 'position'} role${jobCompany ? ` at ${jobCompany}` : ''}.`;
                }

                // Ensure we're using the correct parent file name
                // Remove any leading underscores or special characters if present
                const cleanParentKey = nodeKey.replace(/^_+/, '');
                
                const requestData = {
                    parent_template: cleanParentKey,
                    parent: cleanParentKey,  // Send both for compatibility
                    job_description: jobDescription,
                    focus_type: focusType || 'optimize',
                    batch_mode: true,
                    strategy_focus: getStrategyDescription(focusType || 'optimize'),
                    variant_name: `${jobTitle || 'Quick'}_${jobCompany || 'Branch'}_${Date.now()}`
                };
                
                console.log('Sending API request with parent:', cleanParentKey);
                console.log('Full request data:', requestData);
                
                let response;
                try {
                    response = await fetch('/api/create-variant', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestData)
                    });
                    console.log('API Response received:', response.status, response.statusText);
                } catch (fetchError) {
                    console.error('Fetch error:', fetchError);
                    throw new Error(`Network error: ${fetchError.message}`);
                }
                
                if (response.ok || response.status === 202) {
                    const responseData = await response.json();
                    console.log('API Response data:', responseData);
                    
                    if (responseData.job_id) {
                        // Async job started - show progress and poll for completion
                        showNotification('Branch creation started - this may take 2-5 minutes...', 'info');
                        
                        // Add immediate visual feedback to tree with proper placeholder
                        const tempVariant = {
                            key: `temp_${responseData.job_id}`,
                            name: requestData.variant_name || 'New Branch',
                            description: 'AI generation in progress...',
                            status: 'creating',
                            job_id: responseData.job_id,
                            parents: [nodeKey],
                            generation: 1, // Will be updated when real variant is created
                            created: new Date().toISOString(),
                            is_placeholder: true
                        };
                        await addPlaceholderToTree(tempVariant, nodeKey);
                        
                        // Start polling for job completion
                        pollVariantCreation(responseData.job_id, nodeKey);
                        
                    } else {
                        // Synchronous completion (fallback case)
                        showNotification('Branch created successfully!', 'success');
                        await addVariantToTree(responseData);
                        setTimeout(async () => {
                            await loadGenealogyTree();
                            await loadVariants();
                            renderGenealogyTree();
                            updateDashboard();
                        }, 2000);
                    }
                } else {
                    const errorData = await response.text();
                    console.error('Create variant API error:', errorData);
                    throw new Error(`Failed to create branch: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error creating branch:', error);
                showNotification(`Failed to create branch: ${error.message}`, 'error');
                
                // Remove the temporary "creating" card if it was added
                const tempCards = document.querySelectorAll('.tree-card.creating');
                tempCards.forEach(card => card.remove());
            }
        }

        async function deleteVariantFromTree(nodeKey, nodeName) {
            if (!confirm(`Are you sure you want to delete "${nodeName}"? This cannot be undone.`)) {
                return;
            }
            
            try {
                showNotification('Deleting variant...', 'info');
                
                const response = await fetch(`/api/variants/${nodeKey}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    showNotification('Variant deleted successfully', 'success');
                    
                    // Real-time tree update - remove node immediately
                    removeVariantFromTree(nodeKey);
                    await loadGenealogyTree(); // Refresh tree data
                    renderGenealogyTree(); // Re-render tree
                } else {
                    throw new Error('Failed to delete variant');
                }
            } catch (error) {
                console.error('Error deleting variant:', error);
                showNotification('Failed to delete variant', 'error');
            }
        }

        function showQuickBranchModal(parentKey, parentName) {
            return new Promise((resolve) => {
                const modalHtml = `
                    <div class="quick-branch-modal" id="quick-branch-modal">
                        <div class="quick-branch-content">
                            <div class="quick-branch-header">
                                <h3>🌿 Quick Branch from "${parentName}"</h3>
                                <button onclick="closeQuickBranchModal(false)">&times;</button>
                            </div>
                            <div class="quick-branch-form">
                                <div class="form-group">
                                    <label>Use Saved Job:</label>
                                    <select id="quick-saved-job" onchange="fillFromSavedJob()">
                                        <option value="">Select a saved job description...</option>
                                    </select>
                                </div>
                                
                                <div class="form-divider">
                                    <span>OR Enter Manually</span>
                                </div>
                                
                                <div class="form-group">
                                    <label>Job Title:</label>
                                    <input type="text" id="quick-job-title" placeholder="e.g., Senior Frontend Developer">
                                </div>
                                <div class="form-group">
                                    <label>Company:</label>
                                    <input type="text" id="quick-job-company" placeholder="e.g., TechCorp">
                                </div>
                                <div class="form-group">
                                    <label>Focus Type:</label>
                                    <select id="quick-focus-type">
                                        <option value="frontend-react">Frontend React</option>
                                        <option value="backend-python">Backend Python</option>
                                        <option value="fullstack">Full Stack</option>
                                        <option value="data-science">Data Science</option>
                                        <option value="devops">DevOps</option>
                                        <option value="mobile">Mobile</option>
                                        <option value="custom">Custom</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>AI Command:</label>
                                    <textarea id="quick-agent-command" placeholder="Optimize this resume for..."></textarea>
                                </div>
                                <div class="quick-branch-actions">
                                    <button onclick="createQuickBranch()" class="btn-primary">🌿 Create Branch</button>
                                    <button onclick="closeQuickBranchModal(false)" class="btn-secondary">Cancel</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                // Populate saved jobs dropdown
                populateQuickBranchJobs();
                
                window.quickBranchResolve = resolve;
                window.createQuickBranch = () => {
                    const result = {
                        jobTitle: document.getElementById('quick-job-title').value,
                        jobCompany: document.getElementById('quick-job-company').value,
                        focusType: document.getElementById('quick-focus-type').value,
                        agentCommand: document.getElementById('quick-agent-command').value
                    };
                    closeQuickBranchModal(result);
                };
                window.closeQuickBranchModal = (result) => {
                    document.getElementById('quick-branch-modal').remove();
                    resolve(result);
                };
            });
        }

        function populateQuickBranchJobs() {
            const savedJobSelect = document.getElementById('quick-saved-job');
            if (!savedJobSelect || !availableJobs) return;
            
            // Clear existing options (keep the default one)
            savedJobSelect.innerHTML = '<option value="">Select a saved job description...</option>';
            
            // Add saved jobs with better display names that include company
            availableJobs.forEach(job => {
                const option = document.createElement('option');
                option.value = job.id || job.filename;
                
                // Create a descriptive display name: "Job Title @ Company" or fallback
                let displayName = '';
                const jobTitle = job.job_title || job.title || 'Unknown Position';
                const company = job.company_name || job.company || extractCompanyFromDescription(job.description);
                
                if (company) {
                    displayName = `${jobTitle} @ ${company}`;
                } else {
                    displayName = jobTitle;
                }
                
                // Add filename as fallback if needed
                if (!job.job_title && !job.title) {
                    displayName = job.display_name || job.filename;
                }
                
                option.textContent = displayName;
                option.dataset.jobData = JSON.stringify(job);
                savedJobSelect.appendChild(option);
            });
        }

        function extractCompanyFromDescription(description) {
            if (!description) return null;
            
            // Try to extract company name from common patterns in job descriptions
            const companyPatterns = [
                /Company:\s*([^\n\r]+)/i,
                /at\s+([A-Z][a-zA-Z\s&.,]+?)(?:\s+is\s|,|\.|$)/,
                /([A-Z][a-zA-Z\s&.,]+?)\s+is\s+(?:looking|seeking|hiring)/i,
                /Join\s+([A-Z][a-zA-Z\s&.,]+)/i
            ];
            
            for (const pattern of companyPatterns) {
                const match = description.match(pattern);
                if (match && match[1]) {
                    return match[1].trim();
                }
            }
            
            return null;
        }

        function fillFromSavedJob() {
            const savedJobSelect = document.getElementById('quick-saved-job');
            const selectedOption = savedJobSelect.selectedOptions[0];
            
            if (!selectedOption || !selectedOption.dataset.jobData) {
                // Clear all fields if nothing selected
                document.getElementById('quick-job-title').value = '';
                document.getElementById('quick-job-company').value = '';
                document.getElementById('quick-focus-type').value = 'frontend-react';
                document.getElementById('quick-agent-command').value = '';
                return;
            }
            
            try {
                const jobData = JSON.parse(selectedOption.dataset.jobData);
                console.log('Auto-filling from saved job:', jobData);
                
                // Extract job title from multiple possible fields
                const jobTitle = jobData.job_title || jobData.title || '';
                document.getElementById('quick-job-title').value = jobTitle;
                
                // Extract company from multiple possible fields or description
                const company = jobData.company_name || jobData.company || extractCompanyFromDescription(jobData.description) || '';
                document.getElementById('quick-job-company').value = company;
                
                // Auto-determine focus type from job data
                const focusType = determineFocusTypeFromJob(jobData);
                document.getElementById('quick-focus-type').value = focusType;
                
                // Generate comprehensive AI command from job description
                const aiCommand = generateAICommandFromJob(jobData);
                document.getElementById('quick-agent-command').value = aiCommand;
                
                console.log('Auto-filled values:', { jobTitle, company, focusType, aiCommand });
                
            } catch (error) {
                console.error('Error parsing saved job data:', error);
                showNotification('Error loading saved job data', 'error');
            }
        }

        function determineFocusTypeFromJob(jobData) {
            const description = (jobData.description || '').toLowerCase();
            const title = (jobData.job_title || '').toLowerCase();
            const combined = `${title} ${description}`;
            
            // Frontend patterns
            if (combined.includes('react') || combined.includes('frontend') || combined.includes('front-end')) {
                return 'frontend-react';
            }
            
            // Backend patterns
            if (combined.includes('python') || combined.includes('backend') || combined.includes('back-end') || combined.includes('django') || combined.includes('flask')) {
                return 'backend-python';
            }
            
            // Full stack patterns
            if (combined.includes('full stack') || combined.includes('fullstack')) {
                return 'fullstack';
            }
            
            // Data science patterns
            if (combined.includes('data scientist') || combined.includes('machine learning') || combined.includes('ai ') || combined.includes('analytics')) {
                return 'data-science';
            }
            
            // DevOps patterns
            if (combined.includes('devops') || combined.includes('infrastructure') || combined.includes('cloud') || combined.includes('kubernetes') || combined.includes('docker')) {
                return 'devops';
            }
            
            // Mobile patterns
            if (combined.includes('mobile') || combined.includes('ios') || combined.includes('android') || combined.includes('react native')) {
                return 'mobile';
            }
            
            return 'custom'; // Default fallback
        }

        function generateAICommandFromJob(jobData) {
            const title = jobData.job_title || jobData.title || 'the position';
            const company = jobData.company_name || jobData.company || extractCompanyFromDescription(jobData.description) || 'this company';
            
            let command = `Optimize this resume for the ${title} position at ${company}.`;
            
            // Add the full job description for AI context
            if (jobData.description && jobData.description.trim()) {
                command += `\n\nJob Description:\n${jobData.description.trim()}`;
                
                // Add specific optimization instructions based on content
                const description = jobData.description.toLowerCase();
                
                command += '\n\nOptimization Instructions:';
                
                if (description.includes('requirements') || description.includes('qualifications')) {
                    command += '\n- Focus on highlighting relevant experience and skills that match the job requirements';
                }
                
                if (description.includes('years') && description.includes('experience')) {
                    command += '\n- Emphasize relevant years of experience and career progression';
                }
                
                if (description.includes('leadership') || description.includes('lead') || description.includes('senior')) {
                    command += '\n- Highlight leadership and senior-level accomplishments';
                }
                
                if (description.includes('remote') || description.includes('distributed')) {
                    command += '\n- Emphasize remote work experience and self-direction';
                }
                
                if (description.includes('startup') || description.includes('fast-paced')) {
                    command += '\n- Highlight adaptability, versatility, and startup experience';
                }
                
                command += '\n- Ensure ATS compatibility while maximizing keyword relevance';
                command += '\n- Maintain professional formatting and single-page layout';
            }
            
            return command;
        }

        // Debug function to manually refresh tree (call from console)
        window.debugRefreshTree = async function() {
            console.log('Manual tree refresh triggered...');
            await loadGenealogyTree();
            await loadVariants();
            renderGenealogyTree();
            updateDashboard();
            console.log('Manual tree refresh completed');
        };

        // Poll for variant creation completion
        function pollVariantCreation(jobId, parentNodeKey) {
            let pollCount = 0;
            const maxPolls = 120; // 10 minutes max (5 second intervals)
            
            const pollInterval = setInterval(async () => {
                try {
                    pollCount++;
                    console.log(`Polling variant creation ${jobId} (attempt ${pollCount}/${maxPolls})`);
                    
                    const response = await fetch('/api/variant-status');
                    if (!response.ok) {
                        throw new Error(`Status polling failed: ${response.status}`);
                    }
                    
                    const jobs = await response.json();
                    const ourJob = jobs.find(job => job.job_id === jobId);
                    
                    if (ourJob) {
                        console.log(`Job ${jobId} status:`, ourJob.status, ourJob.progress);
                        
                        // Update placeholder node progress
                        updatePlaceholderProgress(jobId, ourJob.progress, ourJob.status);
                        
                        // Update progress notification occasionally (not every poll)
                        if (pollCount % 3 === 0 && ourJob.progress) {
                            showNotification(ourJob.progress, 'info');
                        }
                        
                        if (ourJob.status === 'completed') {
                            clearInterval(pollInterval);
                            console.log('✅ Variant creation completed:', ourJob.result);
                            
                            showNotification('Branch created successfully!', 'success');
                            
                            // Remove placeholder and refresh tree
                            removePlaceholderNode(jobId);
                            
                            // Refresh tree to show new variant
                            setTimeout(async () => {
                                await loadGenealogyTree();
                                await loadVariants();
                                renderGenealogyTree();
                                updateDashboard();
                                console.log('Tree refreshed after variant completion');
                            }, 1000);
                            
                        } else if (ourJob.status === 'failed') {
                            clearInterval(pollInterval);
                            console.error('❌ Variant creation failed:', ourJob.error);
                            
                            showNotification(`Branch creation failed: ${ourJob.error}`, 'error');
                            
                            // Mark placeholder as failed instead of removing immediately
                            markPlaceholderAsFailed(jobId, ourJob.error);
                            
                            // Remove after 5 seconds to show the error
                            setTimeout(() => {
                                removePlaceholderNode(jobId);
                            }, 5000);
                        }
                    }
                    
                    // Stop polling after max attempts
                    if (pollCount >= maxPolls) {
                        clearInterval(pollInterval);
                        console.warn('⏰ Variant creation polling timed out');
                        showNotification('Branch creation is taking longer than expected. Check back later.', 'warning');
                    }
                    
                } catch (error) {
                    console.error('Error polling variant status:', error);
                    // Don't stop polling for network errors, just log them
                }
            }, 5000); // Poll every 5 seconds
        }

        async function addVariantToTree(newVariant) {
            // Add immediate visual feedback to tree (legacy function)
            const treeCanvas = document.getElementById('tree-canvas');
            if (treeCanvas) {
                const tempCard = document.createElement('div');
                tempCard.className = 'tree-card creating';
                tempCard.innerHTML = `
                    <div class="tree-card-header">
                        <div class="tree-card-title">${newVariant.name || 'Creating...'}</div>
                        <div class="tree-card-badges">
                            <span class="tree-badge new">CREATING</span>
                        </div>
                    </div>
                    <div class="tree-card-content">
                        <div class="tree-card-desc">Generating variant...</div>
                    </div>
                `;
                treeCanvas.appendChild(tempCard);
            }
        }

        async function addPlaceholderToTree(placeholderVariant, parentKey) {
            // Add a proper placeholder node to the tree layout
            const treeCanvas = document.getElementById('tree-canvas');
            if (!treeCanvas) return;

            // Find the parent node to position the placeholder correctly
            const parentCard = document.querySelector(`[data-key="${parentKey}"]`);
            if (!parentCard) {
                console.warn('Parent node not found for placeholder');
                return;
            }

            // Get parent position from its absolute positioning in the tree
            let parentX = 0;
            let parentY = 0;
            
            // The tree cards use absolute positioning with style.left and style.top
            const parentStyle = window.getComputedStyle(parentCard);
            const parentLeft = parentStyle.left;
            const parentTop = parentStyle.top;
            
            if (parentLeft && parentLeft !== 'auto' && parentTop && parentTop !== 'auto') {
                parentX = parseInt(parentLeft) || 0;
                parentY = parseInt(parentTop) || 0;
            } else {
                // Fallback: look for inline styles
                if (parentCard.style.left && parentCard.style.top) {
                    parentX = parseInt(parentCard.style.left) || 0;
                    parentY = parseInt(parentCard.style.top) || 0;
                } else {
                    console.warn('Could not determine parent position from styles');
                    return;
                }
            }
            
            console.log(`Parent card position: x=${parentX}, y=${parentY}`);
            
            // Calculate position using tree hierarchy logic
            const cardWidth = 280;
            const cardHeight = 120;
            const horizontalSpacing = 350; // Same as tree layout
            const verticalSpacing = 150;   // Same as tree layout
            
            // Check if there are already children and offset accordingly
            const existingChildren = treeCanvas.querySelectorAll(`[data-parent-key="${parentKey}"]`);
            const childIndex = existingChildren.length;
            
            // Position placeholder as a child of the parent using tree spacing
            // If multiple children, offset horizontally to avoid overlap
            const placeholderX = parentX + (childIndex * horizontalSpacing);
            const placeholderY = parentY + verticalSpacing;
            
            console.log(`Placeholder position: x=${placeholderX}, y=${placeholderY} (child ${childIndex + 1})`);
            
            // Check for overlaps and adjust if needed
            const allCards = treeCanvas.querySelectorAll('.tree-card');
            let finalX = placeholderX;
            let finalY = placeholderY;
            let adjusted = false;
            
            allCards.forEach(card => {
                const cardX = parseInt(card.style.left) || 0;
                const cardY = parseInt(card.style.top) || 0;
                
                // Check if positions overlap (within 50px)
                if (Math.abs(cardX - finalX) < 50 && Math.abs(cardY - finalY) < 50) {
                    console.log(`Overlap detected with card at ${cardX},${cardY} - adjusting`);
                    finalX += 100; // Shift right to avoid overlap
                    adjusted = true;
                }
            });
            
            if (adjusted) {
                console.log(`Adjusted placeholder position to: x=${finalX}, y=${finalY}`);
            }

            // Create placeholder card
            const placeholderCard = document.createElement('div');
            placeholderCard.className = 'tree-card placeholder creating';
            placeholderCard.dataset.key = placeholderVariant.key;
            placeholderCard.dataset.jobId = placeholderVariant.job_id;
            placeholderCard.style.cssText = `
                position: absolute;
                left: ${placeholderX}px;
                top: ${placeholderY}px;
                width: ${cardWidth}px;
                height: ${cardHeight}px;
                opacity: 0.7;
                filter: grayscale(50%);
            `;

            placeholderCard.innerHTML = `
                <div class="tree-card-header">
                    <div class="tree-card-title">${placeholderVariant.name}</div>
                    <div class="tree-card-badges">
                        <span class="tree-badge status creating">⏳ Building</span>
                        <span class="tree-badge generation">Gen ${placeholderVariant.generation}</span>
                    </div>
                </div>
                <div class="tree-card-content">
                    <div class="tree-card-desc">${placeholderVariant.description}</div>
                    <div class="tree-card-parent">📁 Child of: ${parentKey.replace('.html', '')}</div>
                    <div class="tree-card-progress">
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                        <div class="progress-text">Initializing AI generation...</div>
                    </div>
                </div>
                <div class="tree-card-actions">
                    <button class="tree-btn" disabled title="Building in progress">⏳</button>
                    <button class="tree-btn" disabled title="Building in progress">🤖</button>
                </div>
            `;

            // Add connection line from parent to placeholder using tree coordinates
            const connectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            connectionLine.setAttribute('x1', parentX + (cardWidth / 2));
            connectionLine.setAttribute('y1', parentY + cardHeight);
            connectionLine.setAttribute('x2', placeholderX + (cardWidth / 2));
            connectionLine.setAttribute('y2', placeholderY);
            connectionLine.setAttribute('stroke', '#94a3b8');
            connectionLine.setAttribute('stroke-width', '2');
            connectionLine.setAttribute('stroke-dasharray', '5,5');
            connectionLine.classList.add('placeholder-connection');
            connectionLine.dataset.jobId = placeholderVariant.job_id;

            // Add to tree
            treeCanvas.appendChild(placeholderCard);
            
            // Add connection line to the tree connections SVG
            const svgContainer = treeCanvas.querySelector('.tree-connections');
            if (svgContainer) {
                svgContainer.appendChild(connectionLine);
                
                // Ensure SVG is large enough for the new placeholder
                const currentWidth = parseInt(svgContainer.style.width) || 0;
                const currentHeight = parseInt(svgContainer.style.height) || 0;
                const newWidth = Math.max(currentWidth, placeholderX + cardWidth + 50);
                const newHeight = Math.max(currentHeight, placeholderY + cardHeight + 50);
                
                svgContainer.style.width = `${newWidth}px`;
                svgContainer.style.height = `${newHeight}px`;
            } else {
                console.warn('No SVG container found for placeholder connection line');
            }

            console.log(`Added placeholder node: ${placeholderVariant.name} (${placeholderVariant.job_id})`);
        }

        function updatePlaceholderProgress(jobId, progressText, status) {
            const placeholder = document.querySelector(`[data-job-id="${jobId}"]`);
            if (!placeholder) return;

            const progressTextElement = placeholder.querySelector('.progress-text');
            if (progressTextElement && progressText) {
                progressTextElement.textContent = progressText;
            }

            // Update status badge
            const statusBadge = placeholder.querySelector('.tree-badge.status');
            if (statusBadge) {
                if (status === 'processing') {
                    statusBadge.innerHTML = '🤖 Processing';
                    statusBadge.className = 'tree-badge status processing';
                } else if (status === 'completed') {
                    statusBadge.innerHTML = '✅ Completed';
                    statusBadge.className = 'tree-badge status completed';
                }
            }
        }

        function markPlaceholderAsFailed(jobId, errorMessage) {
            const placeholder = document.querySelector(`[data-job-id="${jobId}"]`);
            if (!placeholder) return;

            // Update visual styling for failure
            placeholder.classList.add('failed');
            placeholder.style.filter = 'grayscale(80%) opacity(0.6)';

            // Update status badge
            const statusBadge = placeholder.querySelector('.tree-badge.status');
            if (statusBadge) {
                statusBadge.innerHTML = '❌ Failed';
                statusBadge.className = 'tree-badge status failed';
            }

            // Update progress text
            const progressTextElement = placeholder.querySelector('.progress-text');
            if (progressTextElement) {
                progressTextElement.textContent = `Failed: ${errorMessage}`;
                progressTextElement.style.color = '#dc2626';
            }

            // Stop progress bar animation
            const progressFill = placeholder.querySelector('.progress-fill');
            if (progressFill) {
                progressFill.style.animation = 'none';
                progressFill.style.background = '#dc2626';
                progressFill.style.width = '100%';
            }
        }

        function removePlaceholderNode(jobId) {
            const placeholder = document.querySelector(`[data-job-id="${jobId}"]`);
            if (placeholder) {
                placeholder.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                placeholder.style.opacity = '0';
                placeholder.style.transform = 'scale(0.8)';
                
                // Also fade out the specific connection line for this job
                const connectionLine = document.querySelector(`.placeholder-connection[data-job-id="${jobId}"]`);
                if (connectionLine) {
                    connectionLine.style.transition = 'opacity 0.5s ease';
                    connectionLine.style.opacity = '0';
                }
                
                setTimeout(() => {
                    placeholder.remove();
                    if (connectionLine) {
                        connectionLine.remove();
                    }
                }, 500);
                console.log(`Removed placeholder node: ${jobId}`);
            }
        }

        function removeVariantFromTree(nodeKey) {
            // Immediately remove the node from the tree
            const nodeCard = document.querySelector(`[data-key="${nodeKey}"]`);
            if (nodeCard) {
                nodeCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                nodeCard.style.opacity = '0';
                nodeCard.style.transform = 'scale(0.8)';
                setTimeout(() => {
                    nodeCard.remove();
                }, 300);
            }
        }

        function getVariantStatusBadge(node) {
            // Check if variant is currently being created/processed
            if (node.status === 'creating' || node.is_creating) {
                return '<span class="tree-badge status creating">⏳ Creating</span>';
            }
            
            // Check if variant failed to create
            if (node.status === 'failed' || node.has_errors) {
                return '<span class="tree-badge status failed">❌ Failed</span>';
            }
            
            // Check if variant is ready/completed
            if (node.status === 'completed' || node.file_exists) {
                return '<span class="tree-badge status completed">✅ Ready</span>';
            }
            
            // Check if variant is being processed by AI
            if (node.status === 'processing') {
                return '<span class="tree-badge status processing">🤖 Processing</span>';
            }
            
            // Default state
            return '<span class="tree-badge status pending">⏸️ Pending</span>';
        }

        // Status polling for active variants
        let statusPollingInterval;
        
        function startStatusPolling() {
            if (statusPollingInterval) {
                clearInterval(statusPollingInterval);
            }
            
            statusPollingInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/variant-status');
                    if (response.ok) {
                        const statusUpdates = await response.json();
                        updateVariantStatuses(statusUpdates);
                    }
                } catch (error) {
                    console.error('Error polling variant status:', error);
                }
            }, 5000); // Poll every 5 seconds
        }

        function updateVariantStatuses(statusUpdates) {
            statusUpdates.forEach(update => {
                const nodeCard = document.querySelector(`[data-key="${update.key}"]`);
                if (nodeCard) {
                    // Update the status badge
                    const badgeContainer = nodeCard.querySelector('.tree-card-badges');
                    const existingStatusBadge = badgeContainer.querySelector('.tree-badge.status');
                    
                    const newStatusBadge = getVariantStatusBadge(update);
                    
                    if (existingStatusBadge) {
                        existingStatusBadge.outerHTML = newStatusBadge;
                    } else {
                        badgeContainer.insertAdjacentHTML('afterbegin', newStatusBadge);
                    }
                    
                    // Update card class for visual state
                    nodeCard.className = nodeCard.className.replace(/\s*(creating|processing|failed|completed|pending)/g, '');
                    if (update.status) {
                        nodeCard.classList.add(update.status);
                    }
                }
            });
        }
    </script>
</body>
</html>